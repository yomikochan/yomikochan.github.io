<h3 id="about-algorithm">About algorithm</h3>

<p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Union-Find algorithm</a>(also called a Disjoint-set or Merge find algorithm) is a very useful data structure.</p>

<h3 id="references">References</h3>

<p>Recommend to see this document:<a href="https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf">Union-Find.pdf</a></p>

<h3 id="algorithm-implementation">Algorithm implementation</h3>

<p>Below is an algorithm I implemented in C Programming language:</p>

<pre><code class="language-C">#include &lt;iostream&gt;
const int N = 10010;
int id[N];
void init()
{
	for (int i = 0; i &lt; N; i++)
		id[i] = i;
}
int find(int r)
{
	while (id[r] != r)	r = id[r];
	return r;
}
void transplant(int i) // path compression
{
	int r = find(i);
	while (i != r)
	{
		int p = id[i];
		id[i] = r;
		i = p;
	}
}
bool issmooth(int p, int q)
{
	return find(p) == find(q);
}
void join(int p, int q)
{
	int r1 = find(p), r2 = find(q);
	if (r1 != r2)
		id[r1] = r2;
}
int main()
{
	init();
	for (int i = 0; i &lt; 8; i++)
		cout &lt;&lt; i &lt;&lt; "-&gt;" &lt;&lt; id[i] &lt;&lt; ' ';

	join(1, 2);
	join(1, 3);
	join(2, 4);
	join(5, 6);
	join(6, 7);
	join(6, 8);

	if (issmooth(2, 7))
		cout &lt;&lt; "true" &lt;&lt; endl;
	else
		cout &lt;&lt; "false" &lt;&lt; endl;

	transplant(1);
	for (int i = 0; i &lt; 8; i++)
		cout &lt;&lt; i &lt;&lt; "-&gt;" &lt;&lt; id[i] &lt;&lt; ' ';
	getchar();
	return 0;
}

/*
	1--2--4
	| /
	|/
	3
	5--6--7
	   |
	   8
*/
</code></pre>
