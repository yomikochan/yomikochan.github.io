<h3 id="简介">简介</h3>

<p>哈希树又叫做<a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>。广泛应用于密码学领域进行数据加密。个人也很喜欢这个算法。</p>

<h3 id="数据结构">数据结构</h3>

<p>一张十分易懂的图(来源：https://blog.csdn.net/yang_yulei/article/details/46337405) ：</p>

<p><img src="http://img.it610.com/image/info5/41313cddbbed46e8aee99b9ffd72654e.jpg" alt="hash_tree.png" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;class T1, class T2&gt; struct BaseNode {
    T1 key; T2 val;
    BaseNode*next[N];
}
</code></pre></div></div>

<h3 id="加权函数">加权函数</h3>

<p>由于key数据主要使用字符串类型，所以我们先考虑将字符串进行加权。沿用了我做<code class="language-plaintext highlighter-rouge">Json解析器</code>时用到的加权函数。稍有不同的是，这里直接使用每一个字符的<code class="language-plaintext highlighter-rouge">ascii</code>码乘以字符的位置，最后再加上字符串长度。因为考虑到数字类的字符的<code class="language-plaintext highlighter-rouge">ascii</code>码比字符<code class="language-plaintext highlighter-rouge">A</code>小，会出现负数。设字符串长度为 $ n $，则加权函数为</p>

\[weight(s) = n + \sum_{i = 0}^{n} s_{i} \cdot (i + 1)\]

<p>即</p>

<pre><code class="language-C++">ll weight(string key)
{
    ll x = 0; size_t i = 0;
    for (; i &lt; key.size(); i++) x += key[i]*(i + 1);
    return x + i;
}
</code></pre>

<h3 id="算法解析">算法解析</h3>

<p>显然，树由上而下变得越来越茂密，因为，根据质数的性质，如果质数越小，则能被其整除的数越多，所以，发生碰撞的概率越大，于是这样就导致了树的形状。
关于为什么质数只使用到 $ 29 $，每一层的子节点数最大为 $ 32 $ 的问题，我认为看严谨的数学证明会更好：https://wenku.baidu.com/view/16b2c7abd1f34693daef3e58.html</p>

<p>ps 还是想说说算法的空间复杂度：第0层1个根节点，第1层为2进制，第0层最多2个子节点，第2层为3进制，每个节点最多3个子节点，第3层为5进制，每个节点最多5个子节点。。。以此类推，注意到每一层的总结点个数为以该层的进制数为底，前一层的进制数为幂，因此最坏情况下，10层的时候，哈希树的总空间大小为：$ 2^1 + 3^2 + 5^3 + 7^5 + 11^7 + 13^{11} + 17^{13} + 19^{17} + 23^{19} + 29^{23} $ 这是一个非常大的数字，所以空间是完全足够的。至于32，每层每个节点都有32个子节点的空间，最大可以 $ mod \ 29 $，所以，下标也不会越界。想要突破第十层，需要比较特殊的一组数，可以连续映射前 10 个质数。其实也很容易突破，只要这组数满足第 $ i $ 个数能被前 $ i $ 个质数整除，就可以了（我之前的加权算法会导致这样的情况，比如，这样一组字符串 “a”,”b”,”c”,”d”，虽然字符串不同，但却都被加权为1，结果 $ 1 \ mod $ 任何数都为1，嘛…后来改为下标从 1 开始就不存在单个字符组成的字符串被加权为 1 的情况了）。但工程中也尽量避免这样的情况，会做一些处理，所以基本上属于概率问题了。</p>

<h3 id="算法实现">算法实现</h3>

<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
#define ll long long
#define MAX_OVERFLOW 0x16
using namespace std;
const int N = 32;
const int prime[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
template&lt;class T&gt;ll weight(T key)
{
    ll x = 0; size_t i = 0;
    for (; key[i]; i++) x += key[i]*(i + 1);
    return x + i;
}
template&lt;class T1, class T2&gt; struct BaseNode {
    T1 key; T2 val;
    unsigned short floor;
    BaseNode*next[N];
    BaseNode() { floor = 0; REP(i, N) next[i] = nullptr; }
    BaseNode(T1 k, T2 v) : key(k), val(v) { floor = 0; REP(i, N) next[i] = nullptr; }
};
template&lt;class T1, class T2&gt;
class HashTree {
private:
    T2 return_type_value;
    BaseNode&lt;T1, T2&gt;*root;
    void destory(BaseNode&lt;T1, T2&gt;*&amp;r)
    {
        if (r)
        {
            REP(i, prime[r-&gt;floor]) destory(r-&gt;next[i]);
            delete r;
        }
    }
    void print(BaseNode&lt;T1, T2&gt;*&amp;r)
    {
        if (r)
        {
            REP(i, prime[r-&gt;floor]) print(r-&gt;next[i]);
            cout &lt;&lt; r-&gt;key &lt;&lt; ":" &lt;&lt; r-&gt;val &lt;&lt; endl;
        }
    }
    BaseNode&lt;T1, T2&gt;* findkey(T1 key)
    {
        BaseNode&lt;T1, T2&gt;*p = root;
        if (p)
        {
            size_t i = 0;
            while (p &amp;&amp; p-&gt;key != key)
                p = p-&gt;next[weight(key)%prime[i++]];
            return p;
        }
        return nullptr;
    }
public:
    HashTree()
    {
        root = nullptr;
        if (typeid(T2) == typeid(string))
            return_type_value = string("");
        else if (typeid(T2) == typeid(const char*))
            return_type_value = "";
        else if (typeid(T2) == typeid(char*))
            return_type_value = "";
        else if (typeid(T2) == typeid(long long))
            return_type_value = MAX_OVERFLOW;
        else if (typeid(T2) == typeid(int))
            return_type_value = ~MAX_OVERFLOW | 1;
        else if (typeid(T2) == typeid(unsigned))
            return_type_value = MAX_OVERFLOW &gt;&gt; 1 | 1;
        else if (typeid(T2) == typeid(short))
            return_type_value = ~MAX_OVERFLOW &gt;&gt; 1;
        else if (typeid(T2) == typeid(double))
            return_type_value = MAX_OVERFLOW | 1;
        else if (typeid(T2) == typeid(float))
            return_type_value = MAX_OVERFLOW &gt;&gt; 1 | 1;
        else if (typeid(T2) == typeid(bool))
            return_type_value = false;
        else
            return_type_value = nullptr;
    }
    HashTree(T1 k, T2 v) { root = nullptr; insert(k, v); }
    ~HashTree() { destory(root); }
    void insert(T1 key, T2 val)
    {
        BaseNode&lt;T1, T2&gt;*n = new BaseNode&lt;T1, T2&gt;(key, val);
        if (!root)
            root = n;
        else
        {
            if (!findkey(key))
            {
                BaseNode&lt;T1, T2&gt;*p = root; size_t i = 0;
                while (p-&gt;next[weight(key)%prime[i]])
                    p = p-&gt;next[weight(key)%prime[i++]];
                n-&gt;floor = i + 1;
                p-&gt;next[weight(key)%prime[i]] = n;
            }
        }
    }
    void update(T1 key, T2 val)
    {
        BaseNode&lt;T1, T2&gt;*p = findkey(key);
        if (p) p-&gt;val = val;
        else
        {
            cerr &lt;&lt; "Not found the key!" &lt;&lt; endl;
            return;
        }
    }
    void remove(T1 key)
    {
        BaseNode&lt;T1, T2&gt;*p = findkey(key);
        if (p)
        {
            size_t i = 0, pos;
            while (!p-&gt;next[i++]) /* pass */;
            pos = i - 1;
            queue&lt;BaseNode&lt;T1, T2&gt;*&gt; children;
            while (i &lt; prime[p-&gt;next[pos]-&gt;floor - 1])
            {
                if (p-&gt;next[i]) children.push(p-&gt;next[i]);
                i++;
            }
            p = p-&gt;next[pos];
            delete p;
            while (!children.empty())
            {
                BaseNode&lt;T1, T2&gt;*siling = children.front(); children.pop();
                BaseNode&lt;T1, T2&gt;*n = p; size_t j = siling-&gt;floor;
                while (p-&gt;next[weight(siling-&gt;key)%prime[j]])
                    p = p-&gt;next[weight(siling-&gt;key)%prime[j++]];
                p-&gt;next[weight(siling-&gt;key)%prime[j]] = siling;
            }
        }
        else
        {
            cerr &lt;&lt; "Not found the key!" &lt;&lt; endl;
            return;
        }
    }
    void visual()
    {
        print(root);
    }
    T2&amp; GetValue(T1 key)
    {
        BaseNode&lt;T1, T2&gt;*n = findkey(key);
        if (n)
            return n-&gt;val;
        cerr &lt;&lt; "Not found the key!" &lt;&lt; endl;
        return return_type_value;
    }
    T2&amp; operator[](T1 key)
    {
        return GetValue(key);
    }
    T2&amp; operator=(T2 val)
    {
        return val;
    }
};
int main()
{
    HashTree&lt;string, string&gt; n;
    n.insert("one", "first");
    n.insert("two", "second");
    n.insert("three", "third");
    n.insert("four", "fourth");
    n.insert("five", "fifth");
    n.insert("six", "sixth");

    cout &lt;&lt; n["two"] &lt;&lt; endl;
    cout &lt;&lt; n["three"] &lt;&lt; endl;
    cout &lt;&lt; n["one"] &lt;&lt; endl;
    n["one"] = "error"; // 还可以通过这样的方式进行赋值
    cout &lt;&lt; n["one"] &lt;&lt; endl;

    n.visual();

    return 0;
}
</code></pre>

<p>output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>second
third
first
error
six:sixth
five:fifth
three:third
two:second
four:fourth
one:error
</code></pre></div></div>
