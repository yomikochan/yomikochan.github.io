<h3 id="代码">代码</h3>

<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
#define MP make_pair
#define PB push_back
#define st first
#define nd second
#define rd third
#define rg register
#define FOR(i, a, b) for(int i =(a); i &lt;=(b); ++i)
#define RE(i, n) FOR(i, 1, n)
#define FORD(i, a, b) for(int i = (a); i &gt;= (b); --i)
#define REP(i, n) for(int i = 0;i &lt;(n); ++i)
#define VAR(v, i) __typeof(i) v=(i)
#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
using namespace std;
#define l(i) ((i) &lt;&lt; 1)
#define r(i) ((i) &lt;&lt; 1 | 1)
const int N = 500010;
struct { int l, r, val, tag; } segment[N];
inline int read()
{
    char c; int ret = 0, sgn = 1;
    do{c = getchar();}while((c &lt; '0' || c &gt; '9') &amp;&amp; c != '-');
    if(c == '-') sgn = -1; else ret = c - '0';
    while((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0');
    return sgn * ret;
}
void build(int num[], int s, int e, int p)
{
    if (s == e) segment[p].val = num[s];
    else
    {
        segment[p].tag = 0;
        int m = (s + e) &gt;&gt; 1;
        build(num, s, m, l(p));
        build(num, m + 1, e, r(p));
        segment[p].val = segment[l(p)].val + segment[r(p)].val;
    }
}
void update(int s, int e, int b, int f, int p, int v)
{
    if (b &lt;= s &amp;&amp; e &lt;= f)
    {
        segment[p].val += v*(e - s + 1);
        segment[p].tag += v;
        return;
    }
    int m = (s + e) &gt;&gt; 1;
    segment[l(p)].tag += segment[p].tag;
    segment[l(p)].val += segment[p].tag*(m - s + 1);
    segment[r(p)].tag += segment[p].tag;
    segment[r(p)].val += segment[p].tag*(e - m);
    segment[p].tag = 0;
    if (b &lt;= m) update(s, m, b, f, l(p), v);
    if (f &gt; m) update(m + 1, e, b, f, r(p), v);
    segment[p].val = segment[l(p)].val + segment[r(p)].val;
}
int query(int s, int e, int b, int f, int p)
{
    if (b &lt;= s &amp;&amp; e &lt;= f) return segment[p].val;
    int m = (s + e) &gt;&gt; 1, ans = 0;
    segment[l(p)].tag += segment[p].tag;
    segment[l(p)].val += segment[p].tag*(m - s + 1);
    segment[r(p)].tag += segment[p].tag;
    segment[r(p)].val += segment[p].tag*(e - m);
    segment[p].tag = 0;
    if (b &lt;= m) ans += query(s, m, b, f, l(p));
    if (f &gt; m) ans += query(m + 1, e, b, f, r(p));
    return ans;
}
int main()
{
    int n, m, num[N], x, y, v, opera;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; num[i];
    build(num, 1, n, 1);
    while (m--)
    {
        cin &gt;&gt; opera;
        switch(opera)
        {
            case 1: cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; update(1, n, x, y, 1, v); break;
            case 2: cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, n, x, y, 1) &lt;&lt; endl; break;
        }
    }
    return 0;
}
</code></pre>
