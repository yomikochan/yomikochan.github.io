<h3 id="算法简介">算法简介</h3>

<p>感觉是老生常谈的算法了（其实咱就是来水一下&gt; &lt;）。但还是稍微说一下这个算法：对于形如 $ y = f(x) = 0 $ 这样的方程，初中的时候大部分的方程我们都可以使用求根公式解决，但实际上有许多方程我们很难求出它的根，于是只能用数值分析方法来逼近根值。基本原理:设 $ y=f(x) $ 在 $ x \in [a,b] $  上连续，如果有 $ f(a)*f(b) &lt; 0 $ ，则 $ f(x), x \in (a, b) $ 一定过零点（记不得叫啥定理了，好像叫费马引理。至于为什么，画个图就很容易明白了。），那么 $ f(x) $ 在点 $ x_0, (a &lt; x_0 &lt; b)$ 处的切线方程也过零点，根据 $ f(x) $ 曲线的类型：递增、递减、凸或凹，我们会发现起点的选择对于切线随着点向根方向移动时的效率也是不同的。</p>

<p>比如：若 $ x \in [a, b], f(a) &lt; 0, f(b) &gt; 0, f’‘(x) &lt; 0 $ 时，起点应从a点开始迭代效率会更高，即考察 $ f(a) $ 与 $ f’‘(x) $ 是否同号，如果同号，则a点为起点，否则b点为起点。</p>

<p>总之，根据 $ y = f(x) $ 在 $ x_0 $ 处求出切线方程有：</p>

\[f(x) - f(x_0) = f'(x_0)(x - x_0)\]

<p>由于 $ f(x) = 0 $，所以有：</p>

\[x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}\]

<p>再在点 $ (x_1, f(x_1)) $ 作切线，可得根得近似值 $ x_2 $.如此反复进行，一般的，在点(x_{n-1}, f(x_{n-1}))作切线，最终可得到迭代方程：</p>

\[x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\]

<p>算法原理参考：高等数学。</p>

<p>想要再详细了解的同学可以看看：<a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton’s method</a></p>

<h3 id="算法实现">算法实现</h3>

<p>这里我使用函数指针方式来保证接口使用的便利性，虽然可变长参数还没做处理，这一点有空再完善吧。。。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">typedef</span> <span class="nf">double</span><span class="p">(</span><span class="o">*</span><span class="n">equaton</span><span class="p">)(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">double</span> <span class="nf">square</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">newton_method</span><span class="p">(</span><span class="n">equaton</span> <span class="n">func</span><span class="p">,</span> <span class="n">equaton</span> <span class="n">der_func</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isbump</span><span class="p">,</span> <span class="kt">double</span> <span class="err">λ</span><span class="p">)</span> <span class="c1">// isbump： 凹 is true; 凸 is false</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">pre_x</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isbump</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">pre_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">-=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">der_func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&gt;</span> <span class="err">λ</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">pre_x</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="err">λ</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"方程的根为："</span> <span class="o">&lt;&lt;</span> <span class="n">newton_method</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">func2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>测试：</p>

<p>$ f(x) = x^3 + x^2 - 1 $</p>

<p>output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>方程的根为：0.754878
</code></pre></div></div>

<p>更新：增加了两个函数，一个是 $ f(x) $ 的二阶导函数，一个是判断原函数凹凸。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">typedef</span> <span class="nf">double</span><span class="p">(</span><span class="o">*</span><span class="n">equaton</span><span class="p">)(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">double</span> <span class="nf">square</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">func3</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isbump</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mf">1e-2</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">func3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">newton_method</span><span class="p">(</span><span class="n">equaton</span> <span class="n">func</span><span class="p">,</span> <span class="n">equaton</span> <span class="n">der_func</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isc</span><span class="p">,</span> <span class="kt">double</span> <span class="err">λ</span><span class="p">)</span> <span class="c1">// isc： 凹 is true; 凸 is false</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)</span>
		<span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">pre_x</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isc</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">pre_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">-=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">der_func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&gt;</span> <span class="err">λ</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">pre_x</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="err">λ</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"方程的根为："</span> <span class="o">&lt;&lt;</span> <span class="n">newton_method</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">func2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">isbump</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>测试：</p>

<p>$ f(x) = cos(x) - x^3 $</p>

<p>output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>方程的根为：0.865474
</code></pre></div></div>

<p><img src="img/cosx-x^3.png" alt="图1" /></p>

<p>关于牛顿法开方（或任意次方）算法，强烈推荐看看这个回答：https://www.guokr.com/question/461510/</p>

<p>简单提一下需要注意得地方：求 $ \sqrt{2} $ 时，考虑有 $ x^2 - a = 0 $，即 $ x = \pm \sqrt{a} $，于是 $ x $ 就是迭代公式中的 $ x_i $，$ a = 2 $ 就是我们要求的。回答中给出了求任意次方时的公式，直接套用即可。</p>

<p>开方代码实现：</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
int main()
{
	double x, pre_x;
	x = 1;
	pre_x = 9999;
	while (fabs(pre_x - x) &gt; 0)
	{
		pre_x = x;
		x = (x + (2 / x)) / 2;
	}
	std::cout &lt;&lt; x &lt;&lt; std::endl;
	return 0;
}
</code></pre>

<p>牛顿法求 $ x^n $ 算法实现（代码有误）：</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
double newton_method_power(double a, double b)
{
	if (a == 0.)
		return 0.;
	else if (a == 1. || b == 0.)
		return 1.;
	else if (b == 1.)
		return a;
	else if (fabs(b) &gt; 1.)
		return 0.; // 当指数|b| &gt; 1 且为整数时,使用快速幂算法；为浮点数时，可以使用微分近似法或泰勒公式求解
	else
	{
		b = 1./b;
		double x, pre_x;
		x = 1.;
		pre_x = 9999.;
		while (fabs(pre_x - x) &gt; 0.)
		{
			pre_x = x;
			x = ((b - 1.)*x / b) + (a / (b*newton_method_power(x, b - 1.)));
		}
		return x;
	}
}
int main()
{	
	std::cout &lt;&lt; newton_method_power(8., 1.) &lt;&lt; std::endl;
	return 0;
}
</code></pre>
<p>微分近似公式：</p>

\[f(x + \Delta x) \approx f(x) + f'(x) \cdot \Delta x\]

<p>例如：</p>

<p>1.求 $ 2^{1.4} $</p>

<p>由 $ f(x) = a^x $，$ f(x + \Delta x) = a^{x + \Delta x} \approx a^{x} + a^{x} ln(a) \cdot \Delta x $
有 $ 2^{1 + 0.4} \approx 2 + 2ln(2) \cdot 0.4 \approx 2.554518… $
而原表达式 $ 2^{1.4} = 2.63902… $</p>

<p>2.求 $ 2^{9} $</p>

<p>利用公式有 $ 2^{10 - 1} = (2^{10})^{(1 - \frac{1}{10})} \approx 2^{10} + 2^{10} ln(2^{10}) \cdot 0.1 \approx 709.783… $
$ 2^9 = 512 $</p>

<h3 id="参考">参考</h3>

<p>1.<a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton’s method - wikipedia</a>
2.<a href="https://www.guokr.com/question/461510/">果壳网</a></p>
