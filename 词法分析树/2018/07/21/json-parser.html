<h1 id="更新日志">更新日志</h1>

<p>该项目更新日志历史按最新时间排序。</p>

<h3 id="update-2018-10-12">Update 2018-10-12</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>修复了<code class="language-plaintext highlighter-rouge">TextChecker()</code>、<code class="language-plaintext highlighter-rouge">Erase()</code>、<code class="language-plaintext highlighter-rouge">ToString()</code>的bug;</li>
  <li>增加了<code class="language-plaintext highlighter-rouge">ToHttpRequestHeader()</code>功能，用于将json文本解析为http协议请求头部格式；</li>
  <li><code class="language-plaintext highlighter-rouge">Text</code>类中增加了<code class="language-plaintext highlighter-rouge">RemovePair()</code>功能，与<code class="language-plaintext highlighter-rouge">Journey</code>类中的<code class="language-plaintext highlighter-rouge">Erase()</code>功能相同，都是用于移除一对<code class="language-plaintext highlighter-rouge">key-value</code>。</li>
</ol>

<h3 id="update-2018-10-09">Update 2018-10-09</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>增加了<code class="language-plaintext highlighter-rouge">TextChecker()</code>api，其作用是检测json文本是否合法。用法
    <pre><code class="language-C++">Text t;
const char*s = "{\"hello\":\"world\",\"\":{\"112\":\"few\",\"er\":[1,2,3]}}";
std::cout &lt;&lt; (t.TextChecker(s) ? "true" : "false") &lt;&lt; std::endl;
</code></pre>
  </li>
  <li>改变了一些<code class="language-plaintext highlighter-rouge">api</code>的名称，比如之前的<code class="language-plaintext highlighter-rouge">JsonFormatPrint</code>改为了<code class="language-plaintext highlighter-rouge">Output</code>、<code class="language-plaintext highlighter-rouge">WriteText</code>改为了<code class="language-plaintext highlighter-rouge">WriteToText</code>、<code class="language-plaintext highlighter-rouge">Tojson</code>改为了<code class="language-plaintext highlighter-rouge">ToString</code>，两个类中获取对象名称分别改为了<code class="language-plaintext highlighter-rouge">GetValueIsObject</code>、<code class="language-plaintext highlighter-rouge">GetPair</code>等。</li>
  <li>增加了生成器<code class="language-plaintext highlighter-rouge">Journey</code>类，将基础类型值数据结构从<code class="language-plaintext highlighter-rouge">Value类</code>中拿了出来，并做了许多赋值运算符<code class="language-plaintext highlighter-rouge">=</code>与中括符<code class="language-plaintext highlighter-rouge">[]</code>的重载。使得使用更方便。用法见：<a href="https://github.com/darkchii/C-libhttp/blob/master/exam_json_1.cpp">生成器用例</a></li>
</ol>

<p>接下来打算添加迭代器。</p>

<p>源码见：<a href="https://github.com/darkchii/C-libhttp/blob/master/libjson.hpp">libjson.hpp</a></p>

<h3 id="update-2018-10-07">Update 2018-10-07</h3>

<h3 id="pm-1223">pm 12:23</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>增加了对解析好的文本的可操作性（增删改查等），示例见：<a href="https://github.com/darkchii/C-libhttp/blob/master/exam_json.cpp">example</a></li>
  <li>完善了之前一些没注意到的问题。</li>
</ol>

<h3 id="update-2018-10-05">Update 2018-10-05</h3>

<h3 id="pm-0252">pm 02:52</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>完善了之前一些没注意到的问题。</li>
</ol>

<h3 id="update-2018-10-05-1">Update 2018-10-05</h3>

<h3 id="pm-0744">pm 07:44</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>重新设计了数据结构，让数据使用变得更安全；</li>
  <li>修复了字符串转浮点型算法的bug，目前是这样的:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double str2dou(std::string s)
{
 double num = 0, point_back = 0, sign = 1;
 size_t i = 0, pos = 0;
 if (s[i] == '-') i++, sign *= -1;
 while (s[i] != '.') num = num * 10 + (s[i++] - '0');
 pos = i++;
 while (s[i]) point_back = point_back * 10 + (s[i++] - '0');
 num += point_back / std::pow(10, i - pos - 1);
 return num * sign;
}
</code></pre></div>    </div>
  </li>
  <li>更换了解析方式，之前的解析的json格式：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 "string": "hello",
 "double": "-123.43",
 "int": "10",
 "bool": "true",
 "null": "null",
 "array": "["2", "3", "4"]"
}
</code></pre></div>    </div>
    <ul>
      <li>现在的：
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 "string": "hello",
 "double": -123.43,
 "int": 10,
 "bool": true,
 "null": null,
 "array": [2, 3, 4]
}
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>去掉一些多余的变量；</li>
  <li>解析器的使用：
    <pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include "libjson.h"
using namespace std;
int main()
{
 Text t;
 fstream text("json.txt", fstream::in | fstream::out | fstream::app);
 string line, str;
 while (getline(text, line))
     str += line;
 text.close();
 t.Parse(str);
 t.JsonFormatPrint();
 return 0;
}
</code></pre>
    <ul>
      <li>output:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "Latin_Modern" : "fn_lm",
   "Verdana" : "fn_jvn",
   "time" : -123.23,
   "flag" : true
}
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>决定将解析器与生成器分离开，这样更易于使用和维护。（目前基本上完成了解析器部分，生成器正在进行中）</li>
</ol>

<h3 id="update-2018-09-28">Update 2018-09-28</h3>

<h3 id="pm-0755">pm 07:55</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>利用其他方式完善了 <code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">setvalue()</code>，还有 <code class="language-plaintext highlighter-rouge">operator[]</code>，解决了不同类型的传值的增改功能（虽然比较方法比较笨拙）。</li>
  <li>完善了不同类型转换为 <code class="language-plaintext highlighter-rouge">string</code> 的算法，这些都是是辅助算法，应考虑单独放在一个头文件中调用。</li>
</ol>

<p>需要注意的地方：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">add</code>、<code class="language-plaintext highlighter-rouge">setvalue</code>函数只能传入两个字符串，不管 <code class="language-plaintext highlighter-rouge">value</code> 是什么类型都使用字符串进行传入。
用例：
```C++
r.add(“string”, “yes”); // <code class="language-plaintext highlighter-rouge">value</code>为字符串类型
r.set(“string”, “no”); // 同上</li>
</ol>

<p>r.add(“array”, “["one", "two", "three", "four", "five"]”); // <code class="language-plaintext highlighter-rouge">value</code>为字符串数组类型
r.setvalue(“array”, “["Json", "Test", "Fuck"]”); // 同上</p>

<p>r.add(“double”, “324.23”); // <code class="language-plaintext highlighter-rouge">value</code>为浮点类型
r.setvalue(…); // 同上</p>

<p>r.add(“bool”, “true”); // <code class="language-plaintext highlighter-rouge">value</code>为布尔类型
r.setvalue(…); // 同上</p>

<p>r.add(“root”, “{"parent":"children"}”)// <code class="language-plaintext highlighter-rouge">value</code>为Json对象类型
r.setvalue(..); // 同上</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2. 通过 `[]`，获取的 `value` 不是原地址，所以不能进行赋值或修改。也暂不能获取对象类型。`getvalue()` 暂且保留原样。

```C++
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
#define ll long long
#define index(c) (c - 'A')
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
st weight(const char*s)
{
    st i = 0, x = 0;
    while (s[i]) x += index(s[i])*i, i += 1;
    return x + i;
}
void bits(char s[], st &amp;i, ll x)
{
    if (!x) return ;
    bits(s, i, x/10);
    s[i++] = x%10 + '0';
}
void bits(std::string &amp;s, st &amp;i, ll x)
{
    if (!x) return ;
    bits(s, i, x/10);
    s[i++] = x%10 + '0';
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
const char* bool2con_ch_arr(bool v)
{
    if (v) return "true";
    return "false";
}
ll con_char2int(const char *s)
{
    ll num = 0, sign = 1;
    if (*s == '-') s++, sign *= -1;
	while (*s) num = num * 10 + (*s - '0');
	return num*sign;
}
ll str2int(std::string s)
{
    return con_char2int(s.c_str());
}
std::string int2str(ll num)
{
    std::string s; st i = 0;
    if (num &lt; 0) s += "-", i++;
    bits(s, i, num);
    return s;
}
const char* int2con_ch_arr(ll num)
{
    return int2str(num).c_str();
}
double str2float(const char*s, st p, st r)
{
	double num = 0, propoint = 0, sign = 1;
	if (*s == '-') s++, sign *= -1;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num*sign;
}
double str2dou(const char*s) // 与 str2float() 功能一样
{
    double num = 0, propoint = 0, sign = 1;
    st i = 0, pos = 0;
	if (s[i] == '-') i++, sign *= -1;
	while (s[i] != '.') num = num * 10 + (s[i] - '0'), pos = i++;
	i++;
	while (s[i]) propoint = propoint * 10 + (s[i] - '0');
	num += propoint / std::pow(10, i - pos);
	return num*sign;
}
char* float2ch_arr(double num)
{
    char*s = new char; st i = 0;
    if (num &lt; 0) s[i++] = '-', num *= -1;
    ll x = (ll)num;
    double y = num - x;
    bits(s, i, x);
    s[i++] = '.';
    do {
        y *= 10;
        s[i++] = int(y + 0.1)%10 + '0';
    } while (int(ceil(y)) != int(y + 0.1));
    s[i] = 0;
    return s;
}
const char* float2con_ch_arr(double num)
{
    return (const char*)float2ch_arr(num);
}
std::string float2str(double num)
{
    std::string s(float2con_ch_arr(num));
    return s;
}
void str2arr(std::vector&lt;std::string&gt;&amp; arr_str, const char*s)
{
    std::string str; st i = 0;
    while (*s)
    {
        switch(*s)
        {
            case ',':
                if (i &gt; 0)
                {
                    str[i] = '\0';
                    arr_str.push_back(str);
                    i = 0;
                }
                break;
            case ' ': break;
            default : str[i++] = *s; break;
        }
        s++;
    }
}
const char* arr2con_ch_arr(std::vector&lt;std::string&gt; arr_str)
{
    char*s = new char; st k = 0;
    for (st i = 0; i &lt; arr_str.size(); i++)
    {
        for (st j = 0; j &lt; arr_str[i].size(); j++)
            s[k++] = arr_str[i][j];
        if (i != arr_str.size() - 1) s[k++] = ',';
    }
    s[k] = 0;
    return (const char*)s;
}
class BaseNode {
public:
	bool b_v;
	ll i_v;
	double d_v;
	std::string s_v;
	std::vector&lt;std::string&gt; arr_v;

	std::string key;
	st keys;
	bool isvalue;
	Type type;
	ll table[N];
	BaseNode *children[N], *parent;

	BaseNode()
	{
		keys = 0, isvalue = false, type = OBJECT, parent = nullptr;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	BaseNode(BaseNode*p, const char *k)
	{
		std::string sk(k);
		key = sk, keys = 0, isvalue = false, parent = p;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void print(BaseNode*r, int format)
	{
		if (r)
		{
			std::cout &lt;&lt; '{' &lt;&lt; std::endl;
			for (st i = 0; i &lt; r-&gt;keys; i++)
			{
				BaseNode*node = r-&gt;children[i];
				if (node)
				{
				    for (int j = 0; j &lt; format; j++)
                        std::cout &lt;&lt; '\t';
					std::cout &lt;&lt; "\""  &lt;&lt; node-&gt;key &lt;&lt; "\" : ";
					switch (node-&gt;type)
					{
					case BOOL:
						std::cout &lt;&lt; (node-&gt;b_v ? "true" : "false");
						break;
					case INTEGER:
						std::cout &lt;&lt; node-&gt;i_v;
						break;
					case FLOAT:
						std::cout &lt;&lt; node-&gt;d_v;
						break;
					case STRING:
						std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;s_v &lt;&lt; "\"";
						break;
					case ARRAY:
						std::cout &lt;&lt; '[';
						for (st j = 0; j &lt; node-&gt;arr_v.size(); j++)
						{
							std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; "\"";
							if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; ", ";
						}
						std::cout &lt;&lt; ']';
						break;
					case OBJECT:
						print(r-&gt;children[i], format + 1);
						break;
					}
					if (i != root-&gt;keys - 1) std::cout &lt;&lt; ",";
					std::cout &lt;&lt; std::endl;
				}
			}
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
			std::cout &lt;&lt; '}' &lt;&lt; std::endl;
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
		}
	}
	BaseNode* findkey(BaseNode*r, const char*s)
	{
	    if (r &amp;&amp; r-&gt;table[weight(s)] != -1) return r-&gt;children[r-&gt;table[weight(s)]];
        return nullptr;
	}
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(std::string s)
	{
	    parse(s.c_str());
	}
	void parse(const char *s)
	{
		char str[N]; st i = 0;
		bool arr_sw = false, obj_sw = false, str_sw = false;
		if (!root) root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (obj_sw) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; } break;
			case '}': nd-&gt;isvalue = false; nd = nd-&gt;parent; obj_sw = false; break;
			case '"': if (str_sw) str_sw = false; else str_sw = true;
			    if (i &gt; 0)
                {
                    bool b = false; double dounum = 0;
                    ll intnum = 0; st f = 0, pos = 0;
                    str[i] = '\0';
                    if (!arr_sw)
                    {
                        if (i &lt; 11)
                        {
                            if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
                                (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
                                f = 3, b = str2bool(str);
                            else
                            {
                                for (st j = 0; j &lt; i; j++)
                                    if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
                                    else { f = 0; break; }
                                if (f)
                                {
                                    for (st j = 0; j &lt; i; j++)
                                        if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2;
                                        else  { f = 1, pos = j; break; }
                                    if (f == 2) intnum = str2int(str);
                                    else dounum = str2float(str, pos, i - 1);
                                }
                            }
                        }
                    }
                    else f = 4;
                    if (nd-&gt;isvalue)
                    {
                        if (nd-&gt;children[nd-&gt;keys - 1])
                        {
                            std::string ps(str);
                            switch (f)
                            {
                            case 0:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
                                break;
                            case 1:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
                                break;
                            case 2:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
                                break;
                            case 3:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
                                break;
                            case 4:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (nd-&gt;table[weight(str)] == -1)
                        {
                            BaseNode *n = new BaseNode(nd, str);
                            nd-&gt;children[nd-&gt;keys] = n;
                        }
                    }
                    i = 0, obj_sw = true;
                }
                break;
			case ':': if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; break;
			case ',': if (!arr_sw) { nd-&gt;isvalue = false; if (str_sw) str[i++] = *s; } break;
			case ' ': if (!arr_sw) if (str_sw) str[i++] = *s; break;
			case '[': arr_sw = true; break;
			case ']': arr_sw = false; break;
			case '/': if (str_sw) str[i++] = *s; break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
		    BaseNode*node = root-&gt;children[i];
			std::string str = node-&gt;key;
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			pstr += "=";
			str.clear();
			switch(node-&gt;type)
			{
            case BOOL: if (node-&gt;b_v) str = "true"; else str = "false";
                break;
            case INTEGER: str = int2str(node-&gt;i_v);
                break;
            case FLOAT: str = float2str(node-&gt;d_v);
                break;
            case STRING: str = node-&gt;s_v;
                break;
            default: std::cerr &lt;&lt; "String parse error!" &lt;&lt; std::endl;
                return "";
			}
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
	auto getvalue(const char*key)
	{
	    BaseNode*node = findkey(root, key);
	    if (node)
        {
//            switch(node-&gt;type)
//            {
//            case BOOL: return node-&gt;b_v;
//            case INTEGER: return node-&gt;i_v;
//            case FLOAT: return node-&gt;d_v;
//            case STRING: return node-&gt;s_v;
//            case ARRAY: return node-&gt;arr_v;
//            default: return node-&gt;children[node-&gt;table[weight(key)]];
//            }
            return node-&gt;d_v;
        }
        return 0.0;
	}
	auto operator[](const char*key)
	{
	    BaseNode*node = findkey(root, key);
	    if (node)
        {
            switch(node-&gt;type)
            {
            case BOOL: return bool2con_ch_arr(node-&gt;b_v);
            case INTEGER: return int2con_ch_arr(node-&gt;i_v);
            case FLOAT: return float2con_ch_arr(node-&gt;d_v);
            case STRING: return node-&gt;s_v.c_str();
            case ARRAY: return arr2con_ch_arr(node-&gt;arr_v);
            default: return "";
            // default: return node-&gt;children[node-&gt;table[weight(key)]];
            }
        }
        return "";
	}
	template&lt;class T&gt; T&amp; operator=(T v)
	{
		return v;
	}
	void setvalue(const char*key, const char*value)
	{
        BaseNode*node = findkey(root, key);
        if (node)
        {
            std::string document, k(key), v(value);
            document += "{\"", document += k, document += "\":";
            document += "\"" , document += v, document += "\"}";
            parse(document.c_str());
        }
        else
        {
            std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
            return;
        }
	}
	void add(const char*key, const char*value)
	{
	    BaseNode*node = findkey(root, key);
        if (!node)
        {
            std::string document, k(key), v(value);
            document += "{\"", document += k, document += "\":";
            document += "\"" , document += v, document += "\"}";
            parse(document.c_str());
        }
        else
        {
            std::cerr &lt;&lt; "The key was existed!" &lt;&lt; std::endl;
            return;
        }
	}
	void erase(const char*key)
	{
	    BaseNode*node = findkey(root, key);
        if (node)
        {
            BaseNode*p = node-&gt;parent;
            p-&gt;keys--;
            p-&gt;table[weight(node-&gt;key.c_str())] = -1;
            destory(node);
        }
        else
        {
            std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
            return;
        }
	}
	void visual()
	{
		print(root, 1);
	}
};
int main()
{
    JsonTree r;

    std::fstream context("json.txt", std::fstream::in | std::fstream::out | std::fstream::app);
    std::string line, str;
    while (std::getline(context, line))
        str += line;
    context.close();

    r.parse(str);

    r.add("hello", "world");
    std::cout &lt;&lt; r["hello"] &lt;&lt; std::endl;
    r.visual();

    r.setvalue("hello", "[\"Json\", \"Test\", \"Fuck\"]");
    std::cout &lt;&lt; r["hello"] &lt;&lt; std::endl;
    std::cout &lt;&lt; r["time"] &lt;&lt; std::endl;
    r.visual();
	return 0;
}
</code></pre></div></div>

<p>output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>world
<span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Object"</span> : <span class="o">{</span>
                <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>,
        <span class="o">}</span>
        ,
        <span class="s2">"time"</span> : <span class="nt">-123</span>.23,
        <span class="s2">"flag"</span> : <span class="nb">true</span>,
        <span class="s2">"hello"</span> : <span class="s2">"world"</span>
<span class="o">}</span>
Json,Test,Fuck
<span class="nt">-123</span>.230000000<span class="o">(</span>
<span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Object"</span> : <span class="o">{</span>
                <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>,
        <span class="o">}</span>
        ,
        <span class="s2">"time"</span> : <span class="nt">-123</span>.23,
        <span class="s2">"flag"</span> : <span class="nb">true</span>,
        <span class="s2">"hello"</span> : <span class="o">[</span><span class="s2">"Json"</span>, <span class="s2">"Test"</span>, <span class="s2">"Fuck"</span><span class="o">]</span>
<span class="o">}</span>
<span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Object"</span> : <span class="o">{</span>
                <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>,
        <span class="o">}</span>
        ,
        <span class="s2">"time"</span> : <span class="nt">-123</span>.23,
        <span class="s2">"flag"</span> : <span class="nb">true</span>,
        <span class="s2">"hello"</span> : <span class="o">[</span><span class="s2">"Json"</span>, <span class="s2">"Test"</span>, <span class="s2">"Fuck"</span><span class="o">]</span>,
        <span class="s2">"root"</span> : <span class="o">{</span>
                <span class="s2">"parent"</span> : <span class="s2">"children"</span>,
        <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="am-0400-左右">am 04:00 左右</h3>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>修改了字符串加权函数名 <code class="language-plaintext highlighter-rouge">has()</code> 为 <code class="language-plaintext highlighter-rouge">weight()</code>，这样更合适。</li>
  <li>前面代码中还有一个明显的安全隐患，那就是 <code class="language-plaintext highlighter-rouge">weight()</code> 函数的设计，因为考虑到一些字符的<code class="language-plaintext highlighter-rouge">ascii</code>码比字符<code class="language-plaintext highlighter-rouge">A</code>小，会出现负数，这时会出现数组越界问题。但我考虑暂不做更改，因为我默认所有的 <code class="language-plaintext highlighter-rouge">key</code> 都不会出现那些奇怪的字符。</li>
  <li>完善了一些不合理的地方。</li>
</ol>

<h5 id="个人遇到的一些技术难点">个人遇到的一些技术难点</h5>

<p>为了做出更好的<code class="language-plaintext highlighter-rouge">Json解析器</code>查了许多资料，但我有许多问题得不到解答。在<code class="language-plaintext highlighter-rouge">C++</code>中，不能对传参相同，返回类型不同的函数进行重载，模板也不能自动对返回类型进行推断（除非使用 C++11 auto 以及 C++14 编译器），这样我很难完成下面这样的功能：</p>
<pre><code class="language-C++">container n;
n["one"] = 1;
cout &lt;&lt; n["one"] &lt;&lt; endl;
</code></pre>
<p>即赋值和索引功能。不能自动推断返回值类型，模板就没意义了。。。也许是我的数据结构没设计好？</p>

<h5 id="代码">代码</h5>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
#define ll long long
#define index(c) (c - 'A')
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
st weight(const char*s)
{
	st i = 0, x = 0;
	while (s[i]) x += index(s[i])*i, i += 1;
	return x + i;
}
double str2float(const char *s, st p, st r)
{
	double num = 0, propoint = 0, sign = 1;
	if (*s == '-') s++, sign *= -1;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num * sign;
}
void bits(char s[], st &amp;i, ll x)
{
	if (!x) return;
	bits(s, i, x / 10);
	s[i++] = x % 10 + '0';
}
void bits(std::string &amp;s, st &amp;i, ll x)
{
	if (!x) return;
	bits(s, i, x / 10);
	s[i++] = x % 10 + '0';
}
std::string float2str(double num)
{
	ll x = (ll)num; st i = 0;
	double y = num - x;
	std::string s;
	bits(s, i, x);
	s[i++] = '.';
	do {
		y *= 10;
		s[i++] = int(y + 0.1) % 10 + '0';
	} while (int(ceil(y)) != int(y + 0.1));
	s[i] = 0;
	return s;
}
char* float2ch_arr(double num)
{
	ll x = (ll)num; st i = 0;
	double y = num - x;
	char* s = new char[N &gt;&gt; 1];
	bits(s, i, x);
	s[i++] = '.';
	do {
		y *= 10;
		s[i++] = int(y + 0.1) % 10 + '0';
	} while (int(ceil(y)) != int(y + 0.1));
	s[i] = 0;
	return s;
}
ll con_char2int(const char *s)
{
	ll num = 0, sign = 1;
	if (*s == '-') s++, sign *= -1;
	while (*s) num = num * 10 + (*s - '0');
	return num * sign;
}
ll str2int(std::string s)
{
	return con_char2int(s.c_str());
}
std::string int2str(ll num)
{
	std::string s; st i = 0;
	if (num &lt; 0) s += "-", i++;
	bits(s, i, num);
	return s;
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
class BaseNode {
public:
	bool b_v;
	ll i_v;
	double d_v;
	std::string s_v;
	std::vector&lt;std::string&gt; arr_v;

	std::string key;
	st keys;
	bool isvalue;
	Type type;
	ll table[N];
	BaseNode *children[N], *parent;

	BaseNode()
	{
		keys = 0, isvalue = false, type = OBJECT, parent = nullptr;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	BaseNode(BaseNode*p, const char *k)
	{
		std::string sk(k);
		key = sk, keys = 0, isvalue = false, parent = p;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void print(BaseNode*r, int format)
	{
		if (r)
		{
			std::cout &lt;&lt; '{' &lt;&lt; std::endl;
			for (st i = 0; i &lt; r-&gt;keys; i++)
			{
				BaseNode*node = r-&gt;children[i];
				if (node)
				{
					for (int j = 0; j &lt; format; j++)
						std::cout &lt;&lt; '\t';
					std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;key &lt;&lt; "\" : ";
					switch (node-&gt;type)
					{
					case BOOL:
						std::cout &lt;&lt; (node-&gt;b_v ? "true" : "false");
						break;
					case INTEGER:
						std::cout &lt;&lt; node-&gt;i_v;
						break;
					case FLOAT:
						std::cout &lt;&lt; node-&gt;d_v;
						break;
					case STRING:
						std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;s_v &lt;&lt; "\"";
						break;
					case ARRAY:
						std::cout &lt;&lt; '[';
						for (st j = 0; j &lt; node-&gt;arr_v.size(); j++)
						{
							std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; "\"";
							if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; ", ";
						}
						std::cout &lt;&lt; ']';
						break;
					case OBJECT:
						print(r-&gt;children[i], format + 1);
						break;
					}
					if (i != root-&gt;keys - 1) std::cout &lt;&lt; ",";
					std::cout &lt;&lt; std::endl;
				}
			}
			for (int j = 0; j &lt; format - 1; j++)
				std::cout &lt;&lt; '\t';
			std::cout &lt;&lt; '}' &lt;&lt; std::endl;
			for (int j = 0; j &lt; format - 1; j++)
				std::cout &lt;&lt; '\t';
		}
	}
	BaseNode* findkey(BaseNode*r, const char*s)
	{
		if (r) return r-&gt;children[r-&gt;table[weight(s)]];
		return nullptr;
	}
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(std::string s)
	{
		parse(s.c_str());
	}
	void parse(const char *s)
	{
		char str[N]; st i = 0;
		bool arr_sw = false, obj_sw = false, str_sw = false;
		root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (obj_sw) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; } break;
			case '}': nd = nd-&gt;parent; obj_sw = false; break;
			case '"': if (str_sw) str_sw = false; else str_sw = true;
				if (i &gt; 0)
				{
					bool b = false; double dounum = 0;
					ll intnum = 0; st f = 0, pos = 0;
					str[i] = '\0';
					if (!arr_sw)
					{
						if (i &lt; 11)
						{
							if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
								(str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
								f = 3, b = str2bool(str);
							else
							{
								for (st j = 0; j &lt; i; j++)
									if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
									else { f = 0; break; }
								if (f)
								{
									for (st j = 0; j &lt; i; j++)
										if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2;
										else { f = 1, pos = j; break; }
									if (f == 2) intnum = str2int(str);
									else dounum = str2float(str, pos, i - 1);
								}
							}
						}
					}
					else f = 4;
					if (nd-&gt;isvalue)
					{
						if (nd-&gt;children[nd-&gt;keys - 1])
						{
							std::string ps(str);
							switch (f)
							{
							case 0:
								nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
								nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
								break;
							case 1:
								nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
								nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
								break;
							case 2:
								nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
								nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
								break;
							case 3:
								nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
								nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
								break;
							case 4:
								nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY;
								nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps);
								break;
							}
						}
					}
					else
					{
						if (nd-&gt;table[weight(str)] == -1)
						{
							BaseNode *n = new BaseNode(nd, str);
							nd-&gt;children[nd-&gt;keys] = n;
						}
					}
					i = 0, obj_sw = true;
				}
				break;
			case ':': if (str_sw) str[i++] = *s; else { if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; } break;
			case ',': if (str_sw) str[i++] = *s; else { if (!arr_sw) nd-&gt;isvalue = false; } break;
			case ' ': if (str_sw) str[i++] = *s; break;
			case '[': arr_sw = true; break;
			case ']': arr_sw = false; break;
			case '/': if (str_sw) str[i++] = *s; break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
			BaseNode*node = root-&gt;children[i];
			std::string str = node-&gt;key;
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			pstr += "=";
			str.clear();
			switch (node-&gt;type)
			{
			case BOOL: if (node-&gt;b_v) str = "true"; else str = "false";
				break;
			case INTEGER: str = int2str(node-&gt;i_v);
				break;
			case FLOAT: str = float2str(node-&gt;d_v);
				break;
			case STRING: str = node-&gt;s_v;
				break;
			default: std::cerr &lt;&lt; "String parse error!" &lt;&lt; std::endl;
				return "";
			}
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
	auto getvalue(const char*key)
	{
		BaseNode*node = findkey(root, key);
		if (node)
	    {
	        /*switch(node-&gt;type)
	        {
	        case BOOL: return node-&gt;b_v;
	        case INTEGER: return node-&gt;i_v;
	        case FLOAT: return node-&gt;d_v;
	        case STRING: return node-&gt;s_v;
	        case ARRAY: return node-&gt;arr_v;
	        default: return node-&gt;children[node-&gt;table[weight(key)]];
	        }*/
			return node-&gt;s_v.c_str();
	    }
		return "";
	}
	auto operator[](const char*key)
	{
		return getvalue(key);
	}
	template&lt;class T&gt; T&amp; operator=(T v)
	{
		return v;
	}
	template&lt;class T&gt; void setvalue(const char*key, T value)
	{
		BaseNode*node = findkey(root, key);
		if (node)
		{
			switch (node-&gt;type)
			{
			case BOOL: node-&gt;b_v = value; break;
			case INTEGER: node-&gt;i_v = value; break;
			case FLOAT: node-&gt;d_v = value; break;
			case STRING: node-&gt;s_v = value; break;
			case ARRAY: node-&gt;arr_v = value; break;
			default:
				/* // 如果是直接在原本的value中进行添加，则不用清除，否则就清除所有子节点
	            for (st i = 0; i &lt; node-&gt;keys; i++)
	                destory(node-&gt;children[i]);
	            node-&gt;keys = 0;*/
				for (st i = 0; i &lt; value.size(); i++)
				{
					node-&gt;table[weight(value[i]-&gt;key)] = node-&gt;keys;
					value[i]-&gt;parent = node;
					node-&gt;children[node-&gt;keys++] = value[i];
				}
				break;
			}
		}
		else
		{
			std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
			return;
		}
	}
	template&lt;class T&gt;void add(const char*key, T value)
	{
		BaseNode*node = findkey(root, key);
		if (!node)
		{
			BaseNode*n = new BaseNode(root, key);
			switch (n-&gt;type)
			{
			case BOOL: n-&gt;b_v = value; break;
			case INTEGER: n-&gt;i_v = value; break;
			case FLOAT: n-&gt;d_v = value; break;
			case STRING: n-&gt;s_v = value; break;
			case ARRAY: n-&gt;arr_v = value; break;
			default:
				n-&gt;type = OBJECT;
				for (st i = 0; i &lt; value.size(); i++)
				{
					n-&gt;table[weight(value[i]-&gt;key)] = n-&gt;keys;
					value[i]-&gt;parent = n;
					n-&gt;children[n-&gt;keys++] = value[i];
				}
				break;
			}
			root-&gt;table[weight(key)] = root-&gt;keys++;
			root-&gt;children[root-&gt;keys - 1] = n;
		}
		else
		{
			std::cerr &lt;&lt; "The key was existed!" &lt;&lt; std::endl;
			return;
		}
	}
	void erase(const char*key)
	{
		BaseNode*node = findkey(root, key);
		if (node)
		{
			BaseNode*p = node-&gt;parent;
			p-&gt;keys--;
			p-&gt;table[weight(node-&gt;key.c_str())] = -1;
			destory(node);
		}
		else
		{
			std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
			return;
		}
	}
	void visual()
	{
		print(root, 1);
	}
};
int main()
{
	JsonTree r;

	std::fstream context("json.txt", std::fstream::in | std::fstream::out | std::fstream::app);
	std::string line, str;
	while (std::getline(context, line))
		str += line;
	context.close();
	r.parse(str);
	r.visual();
	// std::cout &lt;&lt; r.getvalue("time") &lt;&lt; std::endl;
	std::cout &lt;&lt; r["Verdana"] &lt;&lt; std::endl;
	// r.setvalue("time", 154.2);
	std::cout &lt;&lt; r.getvalue("Latin_Modern") &lt;&lt; std::endl;
	return 0;
}
</code></pre>

<h3 id="update-2018-09-27">Update 2018-09-27</h3>

<h5 id="am-0503">am 05:03</h5>

<p><strong>此次更新的主要内容</strong></p>

<ol>
  <li>增加了通过<code class="language-plaintext highlighter-rouge">key</code>获取/设置对应的<code class="language-plaintext highlighter-rouge">value</code>的api:<code class="language-plaintext highlighter-rouge">getvalue()</code>、<code class="language-plaintext highlighter-rouge">setvalue()</code>；</li>
  <li>增加了通过<code class="language-plaintext highlighter-rouge">key</code>删除<code class="language-plaintext highlighter-rouge">key-value</code>的api；</li>
  <li>增加了函数<code class="language-plaintext highlighter-rouge">weight()</code>，它的作用是在<code class="language-plaintext highlighter-rouge">json</code>树内建一个<code class="language-plaintext highlighter-rouge">weighth-table</code>，使得能够通过传入关键字<code class="language-plaintext highlighter-rouge">key</code>，在 $ O(n) $（为关键字<code class="language-plaintext highlighter-rouge">key</code>字符串的长度）时间复杂度定位到<code class="language-plaintext highlighter-rouge">key</code>。详细<code class="language-plaintext highlighter-rouge">防止映射冲突</code>算法是通过将字符串每一位字符 <code class="language-plaintext highlighter-rouge">c</code> 减去 <code class="language-plaintext highlighter-rouge">ascii</code> 码 <code class="language-plaintext highlighter-rouge">A</code>的值乘以该字符所处的字符串中的位置，然后将每一位求和，最后再加上字符串长度。设字符串为 $ s $，长度为 $ l $，则用数学公式表示为：
\(weight(s) = l + \sum_{i = 0}^{l} (s[i] - 'A')*i\)</li>
  <li>重载了<code class="language-plaintext highlighter-rouge">[]</code>符，使其能够通过字符串<code class="language-plaintext highlighter-rouge">key</code>来获取或设置<code class="language-plaintext highlighter-rouge">value</code>值。但并不完善。只能对一种类型的<code class="language-plaintext highlighter-rouge">value</code>进行操作；</li>
  <li>增加了许多内置转换函数：<code class="language-plaintext highlighter-rouge">bits()</code>、<code class="language-plaintext highlighter-rouge">float2str()</code>、<code class="language-plaintext highlighter-rouge">float2ch_arr()</code>、<code class="language-plaintext highlighter-rouge">int2str()</code>、<code class="language-plaintext highlighter-rouge">con_char2int</code>；</li>
  <li>修复了<code class="language-plaintext highlighter-rouge">str2float()</code>与<code class="language-plaintext highlighter-rouge">str2int()</code>为负数时的bug。</li>
  <li>完善了之前一些没注意到地方的。</li>
</ol>

<h5 id="代码-1">代码</h5>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
#define ll long long
#define index(c) (c - 'A')
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
st weight(const char*s)
{
    st i = 0, x = 0;
    while (s[i]) x += index(s[i])*i, i += 1;
    return x + i;
}
double str2float(const char *s, st p, st r)
{
	double num = 0, propoint = 0, sign = 1;
	if (*s == '-') s++, sign *= -1;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num*sign;
}
void bits(char s[], st &amp;i, ll x)
{
    if (!x) return ;
    bits(s, i, x/10);
    s[i++] = x%10 + '0';
}
void bits(std::string &amp;s, st &amp;i, ll x)
{
    if (!x) return ;
    bits(s, i, x/10);
    s[i++] = x%10 + '0';
}
std::string float2str(double num)
{
    ll x = (ll)num; st i = 0;
    double y = num - x;
    std::string s;
    bits(s, i, x);
    s[i++] = '.';
    do {
        y *= 10;
        s[i++] = int(y + 0.1)%10 + '0';
    } while (int(ceil(y)) != int(y + 0.1));
    s[i] = 0;
    return s;
}
char* float2ch_arr(double num)
{
    ll x = (ll)num; st i = 0;
    double y = num - x;
    char* s = new char[N &gt;&gt; 1];
    bits(s, i, x);
    s[i++] = '.';
    do {
        y *= 10;
        s[i++] = int(y + 0.1)%10 + '0';
    } while (int(ceil(y)) != int(y + 0.1));
    s[i] = 0;
    return s;
}
ll con_char2int(const char *s)
{
    ll num = 0, sign = 1;
    if (*s == '-') s++, sign *= -1;
	while (*s) num = num * 10 + (*s - '0');
	return num*sign;
}
ll str2int(std::string s)
{
    return con_char2int(s.c_str());
}
std::string int2str(ll num)
{
    std::string s; st i = 0;
    if (num &lt; 0) s += "-", i++;
    bits(s, i, num);
    return s;
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
class BaseNode {
public:
	bool b_v;
	ll i_v;
	double d_v;
	std::string s_v;
	std::vector&lt;std::string&gt; arr_v;

	std::string key;
	st keys;
	bool isvalue;
	Type type;
	ll table[N];
	BaseNode *children[N], *parent;

	BaseNode()
	{
		keys = 0, isvalue = false, type = OBJECT, parent = nullptr;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	BaseNode(BaseNode*p, const char *k)
	{
		std::string sk(k);
		key = sk, keys = 0, isvalue = false, parent = p;
		for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void print(BaseNode*r, int format)
	{
		if (r)
		{
			std::cout &lt;&lt; '{' &lt;&lt; std::endl;
			for (st i = 0; i &lt; r-&gt;keys; i++)
			{
				BaseNode*node = r-&gt;children[i];
				if (node)
				{
				    for (int j = 0; j &lt; format; j++)
                        std::cout &lt;&lt; '\t';
					std::cout &lt;&lt; "\""  &lt;&lt; node-&gt;key &lt;&lt; "\" : ";
					switch (node-&gt;type)
					{
					case BOOL:
						std::cout &lt;&lt; (node-&gt;b_v ? "true" : "false");
						break;
					case INTEGER:
						std::cout &lt;&lt; node-&gt;i_v;
						break;
					case FLOAT:
						std::cout &lt;&lt; node-&gt;d_v;
						break;
					case STRING:
						std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;s_v &lt;&lt; "\"";
						break;
					case ARRAY:
						std::cout &lt;&lt; '[';
						for (st j = 0; j &lt; node-&gt;arr_v.size(); j++)
						{
							std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; "\"";
							if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; ", ";
						}
						std::cout &lt;&lt; ']';
						break;
					case OBJECT:
						print(r-&gt;children[i], format + 1);
						break;
					}
					if (i != root-&gt;keys - 1) std::cout &lt;&lt; ",";
					std::cout &lt;&lt; std::endl;
				}
			}
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
			std::cout &lt;&lt; '}' &lt;&lt; std::endl;
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
		}
	}
	BaseNode* findkey(BaseNode*r, const char*s)
	{
	    if (r) return r-&gt;children[r-&gt;table[weight(s)]];
        return nullptr;
	}
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(std::string s)
	{
	    parse(s.c_str());
	}
	void parse(const char *s)
	{
		char str[N]; st i = 0;
		bool arr_sw = false, obj_sw = false, str_sw = false;
		root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (obj_sw) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; } break;
			case '}': nd = nd-&gt;parent; obj_sw = false; break;
			case '"': if (str_sw) str_sw = false; else str_sw = true;
			    if (i &gt; 0)
                {
                    bool b = false; double dounum = 0;
                    ll intnum = 0; st f = 0, pos = 0;
                    str[i] = '\0';
                    if (!arr_sw)
                    {
                        if (i &lt; 11)
                        {
                            if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
                                (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
                                f = 3, b = str2bool(str);
                            else
                            {
                                for (st j = 0; j &lt; i; j++)
                                    if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
                                    else { f = 0; break; }
                                if (f)
                                {
                                    for (st j = 0; j &lt; i; j++)
                                        if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2;
                                        else  { f = 1, pos = j; break; }
                                    if (f == 2) intnum = str2int(str);
                                    else dounum = str2float(str, pos, i - 1);
                                }
                            }
                        }
                    }
                    else f = 4;
                    if (nd-&gt;isvalue)
                    {
                        if (nd-&gt;children[nd-&gt;keys - 1])
                        {
                            std::string ps(str);
                            switch (f)
                            {
                            case 0:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
                                break;
                            case 1:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
                                break;
                            case 2:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
                                break;
                            case 3:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
                                break;
                            case 4:
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY;
                                nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (nd-&gt;table[weight(str)] == -1)
                        {
                            BaseNode *n = new BaseNode(nd, str);
                            nd-&gt;children[nd-&gt;keys] = n;
                        }
                    }
                    i = 0, obj_sw = true;
                }
                break;
			case ':': if (str_sw) str[i++] = *s; else { if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; } break;
			case ',': if (str_sw) str[i++] = *s; else { if (!arr_sw) nd-&gt;isvalue = false; } break;
			case ' ': if (str_sw) str[i++] = *s; break;
			case '[': arr_sw = true; break;
			case ']': arr_sw = false; break;
			case '/': if (str_sw) str[i++] = *s; break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
		    BaseNode*node = root-&gt;children[i];
			std::string str = node-&gt;key;
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			pstr += "=";
			str.clear();
			switch(node-&gt;type)
			{
            case BOOL: if (node-&gt;b_v) str = "true"; else str = "false";
                break;
            case INTEGER: str = int2str(node-&gt;i_v);
                break;
            case FLOAT: str = float2str(node-&gt;d_v);
                break;
            case STRING: str = node-&gt;s_v;
                break;
            default: std::cerr &lt;&lt; "String parse error!" &lt;&lt; std::endl;
                return "";
			}
			for (st j = 0; j &lt; str.size(); j++)
				pstr += str[j];
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
	auto getvalue(const char*key)
	{
	    BaseNode*node = findkey(root, key);
	    if (node)
        {
//            switch(node-&gt;type)
//            {
//            case BOOL: return node-&gt;b_v;
//            case INTEGER: return node-&gt;i_v;
//            case FLOAT: return node-&gt;d_v;
//            case STRING: return node-&gt;s_v;
//            case ARRAY: return node-&gt;arr_v;
//            default: return node-&gt;children[node-&gt;table[weight(key)]];
//            }
            return node-&gt;d_v;
        }
        return 0.0;
	}
	auto operator[](const char*key)
	{
	    BaseNode*node = findkey(root, key);
	    if (node)
        {
//            switch(node-&gt;type)
//            {
//            case BOOL: return node-&gt;b_v;
//            case INTEGER: return node-&gt;i_v;
//            case FLOAT: return node-&gt;d_v;
//            case STRING: return node-&gt;s_v;
//            case ARRAY: return node-&gt;arr_v;
//            default: return node-&gt;children[node-&gt;table[weight(key)]];
//            }
            return node-&gt;s_v.c_str();
        }
        return "";
	}
	template&lt;class T&gt; T&amp; operator=(T v)
	{
		return v;
	}
	template&lt;class T&gt; void setvalue(const char*key, T value)
	{
        BaseNode*node = findkey(root, key);
        if (node)
        {
            switch(node-&gt;type)
            {
            case BOOL: node-&gt;b_v = value; break;
            case INTEGER: node-&gt;i_v = value; break;
            case FLOAT: node-&gt;d_v = value; break;
            case STRING: node-&gt;s_v = value; break;
            case ARRAY: node-&gt;arr_v = value; break;
            default: // 如果是直接在原本的value中进行添加，则不用清除，否则就清除所有子节点
    //            for (st i = 0; i &lt; node-&gt;keys; i++)
    //                destory(node-&gt;children[i]);
    //            node-&gt;keys = 0;
                for (st i = 0; i &lt; value.size(); i++)
                {
                    node-&gt;table[weight(value[i]-&gt;key)] = node-&gt;keys;
                    value[i]-&gt;parent = node;
                    node-&gt;children[node-&gt;keys++] = value[i];
                }
                break;
            }
        }
        else
        {
            std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
            return;
        }
	}
	template&lt;class T&gt; void add(const char*key, T value)
	{
        BaseNode*node = findkey(root, key);
        if (!node)
        {
            BaseNode*n = new BaseNode(root, key);
            switch(n-&gt;type)
            {
            case BOOL: n-&gt;b_v = value; break;
            case INTEGER: n-&gt;i_v = value; break;
            case FLOAT: n-&gt;d_v = value; break;
            case STRING: n-&gt;s_v = value; break;
            case ARRAY: n-&gt;arr_v = value; break;
            default:
                n-&gt;type = OBJECT;
                for (st i = 0; i &lt; value.size(); i++)
                {
                    n-&gt;table[weight(value[i]-&gt;key)] = n-&gt;keys;
                    value[i]-&gt;parent = n;
                    n-&gt;children[n-&gt;keys++] = value[i];
                }
                break;
            }
            root-&gt;table[weight(key)] = root-&gt;keys++;
            root-&gt;children[root-&gt;keys - 1] = n;
        }
        else
        {
            std::cerr &lt;&lt; "The key was existed!" &lt;&lt; std::endl;
            return;
        }
	}
	void erase(const char*key)
	{
	    BaseNode*node = findkey(root, key);
        if (node)
        {
            BaseNode*p = node-&gt;parent;
            p-&gt;keys--;
            p-&gt;table[weight(node-&gt;key.c_str())] = -1;
            destory(node);
        }
        else
        {
            std::cerr &lt;&lt; "Not found the key!" &lt;&lt; std::endl;
            return;
        }
	}
	void visual()
	{
		print(root, 1);
	}
};
int main()
{
	JsonTree r;

    std::fstream context("json.txt", std::fstream::in | std::fstream::out | std::fstream::app);
    std::string line, str;
    while (std::getline(context, line))
        str += line;
    context.close();
	r.parse(str);
	r.visual();
	// r.setvalue("time", 156.35);
	std::cout &lt;&lt; r.getvalue("time") &lt;&lt; std::endl;
    std::cout &lt;&lt; r["Verdana"] &lt;&lt; std::endl;
	return 0;
}
</code></pre>

<h5 id="example">example</h5>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
        </span><span class="nl">"Latin_Modern"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"fn_lm"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"Verdana"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"fn_jvn"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"Object"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"Color"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"red"</span><span class="p">,</span><span class="w"> </span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"green"</span><span class="p">,</span><span class="w"> </span><span class="s2">"white"</span><span class="p">]</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nl">"time"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"-123.23"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"flag"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"true"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Object"</span> : <span class="o">{</span>
                <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>,
        <span class="o">}</span>
        ,
        <span class="s2">"time"</span> : <span class="nt">-123</span>.23,
        <span class="s2">"flag"</span> : <span class="nb">true</span>
<span class="o">}</span>
<span class="nt">-123</span>.23 // r.getvalue<span class="o">(</span><span class="s2">"time"</span><span class="o">)</span>
fn_jvn  // r[<span class="s2">"Verdana"</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="update-2018-09-26">Update 2018-09-26</h3>

<h5 id="ps-pm-1521">PS pm 15:21</h5>

<p><strong>此次更新所作的主要工作：</strong></p>

<ol>
  <li>将 <code class="language-plaintext highlighter-rouge">obj_sw</code> 完全设定为对象开关，如果遇到字符 <code class="language-plaintext highlighter-rouge">{</code> 便进入到更深的一层；</li>
  <li>在数据结构中添加了 <code class="language-plaintext highlighter-rouge">isvalue</code> ，正如其名，用来判断正在解析的是否为 <code class="language-plaintext highlighter-rouge">value</code>；</li>
  <li>完善了按 <code class="language-plaintext highlighter-rouge">Json</code> 格式化输出。</li>
</ol>

<h5 id="代码-2">代码</h5>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
double str2float(const char *s, st p, st r)
{
	double num = 0, propoint = 0;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num;
}
st str2int(const char *s)
{
	st num = 0;
	while (*s)
		num = num * 10 + (*s - '0');
	return num;
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
class BaseNode {
public:
	bool b_v;
	st i_v;
	double d_v;
	std::string s_v;
	std::vector&lt;std::string&gt; arr_v;

	std::string key;
	st keys;
	bool isvalue;
	Type type;
	BaseNode *children[N], *parent;

	BaseNode()
	{
		keys = 0, isvalue = false, type = OBJECT, parent = nullptr;
		for (int i = 0; i &lt; N; i++) children[i] = nullptr;
	}
	BaseNode(BaseNode*p, const char *k)
	{
		std::string sk(k);
		key = sk, keys = 0, isvalue = false, parent = p;
		for (int i = 0; i &lt; N; i++) children[i] = nullptr;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void print(BaseNode*r, int format)
	{
		if (r)
		{
			std::cout &lt;&lt; '{' &lt;&lt; std::endl;
			for (st i = 0; i &lt; r-&gt;keys; i++)
			{
				BaseNode*node = r-&gt;children[i];
				if (node)
				{
				    for (int j = 0; j &lt; format; j++)
                        std::cout &lt;&lt; '\t';
					std::cout &lt;&lt; "\""  &lt;&lt; node-&gt;key &lt;&lt; "\" : ";
					switch (node-&gt;type)
					{
					case BOOL:
						std::cout &lt;&lt; (node-&gt;b_v ? "true" : "false");
						break;
					case INTEGER:
						std::cout &lt;&lt; node-&gt;i_v;
						break;
					case FLOAT:
						std::cout &lt;&lt; node-&gt;d_v;
						break;
					case STRING:
						std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;s_v &lt;&lt; "\"";
						break;
					case ARRAY:
						std::cout &lt;&lt; '[';
						for (st j = 0; j &lt; node-&gt;arr_v.size(); j++)
						{
							std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; "\"";
							if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; ", ";
						}
						std::cout &lt;&lt; ']';
						break;
					case OBJECT:
						print(r-&gt;children[i], format + 1);
						break;
					}
					if (i != root-&gt;keys - 1) std::cout &lt;&lt; ",";
					std::cout &lt;&lt; std::endl;
				}
			}
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
			std::cout &lt;&lt; '}' &lt;&lt; std::endl;
			for (int j = 0; j &lt; format - 1; j++)
                std::cout &lt;&lt; '\t';
		}
	}
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(const char *s)
	{
		char str[N]; int i = 0;
		bool arr_sw = false, obj_sw = false;
		root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (obj_sw) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; } break;
			case '}': nd = nd-&gt;parent; obj_sw = false; break;
			case '"':   if (i &gt; 0)
			{
				bool b = false; double dounum = 0;
				st intnum = 0, f = 0, pos = 0;
				str[i] = '\0';
				if (!arr_sw)
				{
					if (i &lt; 11)
					{
					    if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
							(str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
							f = 3, b = str2bool(str);
                        else
                        {
                            for (int j = 0; j &lt; i; j++)
                                if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
                                else { f = 0; break; }
                            if (f)
                            {
                                for (int j = 0; j &lt; i; j++)
                                    if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2;
                                    else { f = 1, pos = j; break; }
                                if (f == 2) intnum = str2int(str);
                                else dounum = str2float(str, pos, i - 1);
                            }
                        }
					}
				}
				else f = 4;
				if (nd-&gt;isvalue)
				{
					std::string ps(str);
					switch (f)
					{
					case 0:
					    nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
						break;
					case 1:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
						break;
					case 2:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
						break;
					case 3:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
						break;
					case 4:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps);
						break;
					}
				}
				else
				{
					BaseNode *n = new BaseNode(nd, str);
					nd-&gt;children[nd-&gt;keys] = n;
				}
				i = 0, obj_sw = true;
			}
						break;
			case ':': nd-&gt;keys += 1; nd-&gt;isvalue = true; break;
			case ',': if (!arr_sw) nd-&gt;isvalue = false; break;
			case ' ': break;
			case '[': arr_sw = true; break;
			case ']': arr_sw = false; break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
			std::string str = root-&gt;children[i]-&gt;key;
			for (auto p : str)
				pstr += p;
			pstr += "=";
			str = root-&gt;children[i]-&gt;s_v;
			for (auto p : str)
				pstr += p;
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
	void visual()
	{
		print(root, 1);
	}
};
int main()
{
	char str[] = "{\"Latin_Modern\":\"fn_lm\", \"Verdana\":\"fn_jvn\", \"Object\": {\"Color\": [\"red\", \"blue\", \"green\", \"white\"]}, \"time\" : \"123.23\", \"flag\": \"true\"}";

	JsonTree r;

	r.parse(str);
	r.visual();
	return 0;
}
</code></pre>

<p>output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Object"</span> : <span class="o">{</span>
                <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>,
        <span class="o">}</span>
        ,
        <span class="s2">"time"</span> : 123.23,
        <span class="s2">"flag"</span> : <span class="nb">true</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="ps-am-3点左右">PS am 3点左右</h5>

<p><strong>此次更新所作的主要工作：</strong></p>

<ol>
  <li>对数组类型做了解析判断；</li>
  <li>重命名了变量 <code class="language-plaintext highlighter-rouge">k</code> 为 <code class="language-plaintext highlighter-rouge">obj_sw</code>，它的主要作用是判断当前数据 <del>是 <code class="language-plaintext highlighter-rouge">key</code> 还是 <code class="language-plaintext highlighter-rouge">value</code>或者是</del> 新的对象的入口。</li>
  <li>添加了按 Json 格式输出的函数；</li>
  <li>完善了一些之前的问题。</li>
</ol>

<h5 id="代码-3">代码</h5>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
double str2float(const char *s, st p, st r)
{
	double num = 0, propoint = 0;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num;
}
st str2int(const char *s)
{
	st num = 0;
	while (*s)
		num = num * 10 + (*s - '0');
	return num;
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
class BaseNode {
public:
	bool b_v;
	st i_v;
	double d_v;
	std::string s_v;
	std::vector&lt;std::string&gt; arr_v;
	BaseNode *children[N];
	std::string key;
	st keys;
	Type type;

	BaseNode()
	{
		keys = 0, type = OBJECT;
	}
	BaseNode(const char *k, st n)
	{
		std::string sk(k);
		key = sk, keys = n;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void print(BaseNode*r)
	{
		if (r)
		{
			std::cout &lt;&lt; '{' &lt;&lt; std::endl;
			for (st i = 0; i &lt; r-&gt;keys; i++)
			{
				BaseNode*node = r-&gt;children[i];
				if (node)
				{
					std::cout &lt;&lt; '\t' &lt;&lt; "\""  &lt;&lt; node-&gt;key &lt;&lt; "\" : ";
					switch (node-&gt;type)
					{
					case BOOL:
						std::cout &lt;&lt; (node-&gt;b_v ? "true" : "false");
						break;
					case INTEGER:
						std::cout &lt;&lt; node-&gt;i_v;
						break;
					case FLOAT:
						std::cout &lt;&lt; node-&gt;d_v;
						break;
					case STRING:
						std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;s_v &lt;&lt; "\"";
						break;
					case ARRAY:
						std::cout &lt;&lt; '[';
						for (st j = 0; j &lt; node-&gt;arr_v.size(); j++)
						{
							std::cout &lt;&lt; "\"" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; "\"";
							if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; ", ";
						}
						std::cout &lt;&lt; ']';
						break;
					case OBJECT:
						print(r-&gt;children[i]);
						break;
					}
					if (i != root-&gt;keys - 1) std::cout &lt;&lt; ",";
					std::cout &lt;&lt; std::endl;
				}
			}
			std::cout &lt;&lt; '}' &lt;&lt; std::endl;
		}
	}
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(const char *s)
	{
		char str[N]; bool arr_sw = false;
		int i = 0, obj_sw = 0;
		root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (obj_sw &gt; 0) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; obj_sw = 0; } break;
			case '}': break;
			case '"':   if (i &gt; 0)
			{
				bool b; double dounum = 0; 
				st intnum = 0, f = 0, pos = 0;
				str[i] = '\0';
				if (!arr_sw)
				{
					if (i &lt; 11)
					{
						for (int j = 0; j &lt; i; j++)
							if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
							else { f = 0; break; }
						if (f)
						{
							for (int j = 0; j &lt; i; j++)
								if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2;
								else { f = 1, pos = j; break; }
							if (f == 2) intnum = str2int(str);
							else dounum = str2float(str, pos, i - 1);
						}
						else if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
							(str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
							f = 3, b = str2bool(str);
					}
				}
				else f = 4;
				if (obj_sw &amp; 1)
				{
					std::string ps(str);
					switch (f)
					{
					case 0:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
						break;
					case 1:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
						break;
					case 2:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
						break;
					case 3:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
						break;
					case 4:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps);
						obj_sw -= 1;
						break;
					}
				}
				else
				{
					BaseNode *n = new BaseNode(str, 0);
					nd-&gt;children[nd-&gt;keys] = n;
				}
				i = 0, obj_sw += 1;
			}
						break;
			case ':': nd-&gt;keys += 1; break;
			case ',': break;
			case ' ': break;
			case '[': arr_sw = true; break;
			case ']': arr_sw = false; break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
			std::string str = root-&gt;children[i]-&gt;key;
			for (auto p : str)
				pstr += p;
			pstr += "=";
			str = root-&gt;children[i]-&gt;s_v;
			for (auto p : str)
				pstr += p;
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
	void visual()
	{
		print(root);
	}
};
int main()
{
	char str[] = "{\"Latin_Modern\":\"fn_lm\", \"Verdana\":\"fn_jvn\", \"Color\":[\"red\",\"blue\",\"green\",\"white\"]}";
	JsonTree r;

	r.parse(str);
	r.visual();
	return 0;
}
</code></pre>

<p>output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
        <span class="s2">"Latin_Modern"</span> : <span class="s2">"fn_lm"</span>,
        <span class="s2">"Verdana"</span> : <span class="s2">"fn_jvn"</span>,
        <span class="s2">"Color"</span> : <span class="o">[</span><span class="s2">"red"</span>, <span class="s2">"blue"</span>, <span class="s2">"green"</span>, <span class="s2">"white"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="update-2018-9-25">Update 2018-9-25</h3>

<p>改用了部分<code class="language-plaintext highlighter-rouge">C++</code>的特点来编写该<code class="language-plaintext highlighter-rouge">Json 解析器</code>，目前只是一个十分简易的解析器，还有许多需要完善的地方。</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#define st size_t
const int N = 1000010;
typedef enum { BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
double str2float(const char *s, st p, st r)
{
	double num = 0, propoint = 0;
	while (*s != '.') num = num * 10 + (*s++ - '0');
	s++;
	while (*s) propoint = propoint * 10 + (*s++ - '0');
	num += propoint / std::pow(10, r - p);
	return num;
}
int str2int(const char *s)
{
	int num = 0;
	while (*s) num = num * 10 + (*s - '0');
	return num;
}
bool str2bool(const char *s)
{
	bool var;
	if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\0') var = true;
	else var = false;
	return var;
}
class BaseNode {
public:
	bool b_v;
	int i_v;
	double d_v;
	std::string s_v;
	BaseNode *children[N];
	std::string key;
	st keys;
	Type type;

	BaseNode()
	{
		keys = 0, type = OBJECT;
	}
	BaseNode(const char *k, st n)
	{
		std::string sk(k);
		key = sk, keys = n;
	}
	~BaseNode() {}
};
class JsonTree {
private:
	BaseNode *root;
	std::string pstr;
	/**/
	void destory(BaseNode*&amp;r)
	{
		if (r)
		{
			for (st i = 0; i &lt; r-&gt;keys; i++)
				destory(r-&gt;children[i]);
			delete r;
		}
	}
public:
	JsonTree() { root = nullptr; }
	JsonTree(const char* s)
	{
		root = nullptr;
		parse(s);
	}
	JsonTree(std::string s)
	{
		root = nullptr;
		parse(s.c_str());
	}
	~JsonTree()
	{
		destory(root);
	}
	void parse(const char *s)
	{
		char str[N]; int i = 0, k = 0;
		root = new BaseNode();
		BaseNode *nd = root;
		while (*s)
		{
			switch (*s)
			{
			case '{': if (k &gt; 0) { nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; k = 0; } break;
			case '}': break;
			case '"':   if (i &gt; 0)
			{
				bool b; double dounum = 0; 
				int intnum = 0, f = 0, pos = 0;
				str[i] = '\0';
				for (int j = 0; j &lt; i; j++)
					if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1;
					else { f = 0; break; }
				if (f)
				{
					for (int j = 0; j &lt; i; j++)
						if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2;
						else { f = 1, pos = j; break; }
					if (f == 2) intnum = str2int(str);
					else dounum = str2float(str, pos, i - 1);
				}
				else if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\0') ||
					(str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\0'))
					f = 3, b = str2bool(str);
				if (k &amp; 1)
				{
					std::string ps(str);
					nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps;
					switch (f)
					{
					case 0:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING;
						break;
					case 1:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum;
						break;
					case 2:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum;
						break;
					case 3:
						nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL;
						nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b;
						break;
					}
				}
				else
				{
					BaseNode *n = new BaseNode(str, 0);
					nd-&gt;children[nd-&gt;keys] = n;
				}
				i = 0, k += 1;
			}
						break;
			case ':': nd-&gt;keys += 1; break;
			case ',': break;
			case ' ': break;
			case '\n': break;
			default:  str[i++] = *s; break;
			}
			s++;
		}
	}
	std::string parse2url(const char*s)
	{
		parse(s);
		for (st i = 0; i &lt; root-&gt;keys; i++)
		{
			std::string str = root-&gt;children[i]-&gt;key;
			for (auto p : str)
				pstr += p;
			pstr += "=";
			str = root-&gt;children[i]-&gt;s_v;
			for (auto p : str)
				pstr += p;
			if (i != root-&gt;keys - 1)
				pstr += "&amp;";
		}
		return pstr;
	}
};
int main()
{
	char str[] = "{\"Latin_Modern\":\"fn_lm\", \"Verdana\":\"fn_jvn\", \"time\":\"723.34\"}"; // "{\"Latin_Modern\":\"fn_lm\",\"Verdana\":\"fn_jvn\", \"Color\":[\"red\",\"blue\",\"green\"]}"
	JsonTree r;

	std::string s = r.parse2url(str);
	std::cout &lt;&lt; "https://darkchii.cn/s/" &lt;&lt; s &lt;&lt; std::endl;
	return 0;
}
</code></pre>

<p>output-vs2017 最新版本</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://darkchii.cn/s/Latin_Modern<span class="o">=</span>fn_lm&amp;Verdana<span class="o">=</span>fn_jvn&amp;time<span class="o">=</span>723.34

C:<span class="se">\U</span>sers<span class="se">\a</span>dimin<span class="se">\s</span>ource<span class="se">\r</span>epos<span class="se">\J</span>sonParseMachine<span class="se">\D</span>ebug<span class="se">\J</span>sonParseMachine.exe <span class="o">(</span>process 18988<span class="o">)</span> exited with code 0.
To automatically close the console when debugging stops, <span class="nb">enable </span>Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the conso
le when debugging stops.
Press any key to close this window <span class="nb">.</span> <span class="nb">.</span> <span class="nb">.</span>
</code></pre></div></div>

<p>output-g++ 6.3.0</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://darkchii.cn/s/Latin_Modern<span class="o">=</span>fn_lm&amp;Verdana<span class="o">=</span>fn_jvn&amp;time<span class="o">=</span>723.34

Process returned 0 <span class="o">(</span>0x0<span class="o">)</span>   execution <span class="nb">time</span> : 0.243 s
Press any key to <span class="k">continue</span><span class="nb">.</span>
</code></pre></div></div>

<h3 id="未完成版">未完成版</h3>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define SIZE 10010
#define ll size_t
typedef enum { BOOLEAN, INTEGER, FLOAT, STRING, ARRAY, OBJECT } Type;
typedef struct obj {
	union {
		bool b_v;
		int i_v;
		double d_v;
		const char *s_v;
		struct obj *children[SIZE];
	} value;

	const char *key;
	ll keys;
	Type type;
} JsonTrees;
struct JsonObj {
	JsonTrees *root;
};
void initialized(struct JsonObj **prt)
{
	*prt = (struct JsonObj *)malloc(sizeof(struct JsonObj));
	(*prt)-&gt;root = (JsonTrees *)malloc(sizeof(JsonTrees));
	memset((*prt)-&gt;root-&gt;value.children, 0, sizeof((*prt)-&gt;root-&gt;value.children));
	(*prt)-&gt;root-&gt;type = OBJECT;
	(*prt)-&gt;root-&gt;key = NULL;
	(*prt)-&gt;root-&gt;keys = 0;
}
JsonTrees *parse(const char *s)
{
	struct JsonObj *prt;
	JsonTrees *r, *nd;
	char str[SIZE];
	int i = 0, k = 0;
	memset(str, 0, sizeof(str));
	initialized(&amp;prt);
	nd = r = prt-&gt;root;
	while (*s)
	{
		switch (*s)
		{
		case '{': if (k &gt; 0) { nd = nd-&gt;value.children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; k = 0; } break;
		case '}': break;
		case '"': if (i &gt; 0) {
					str[i] = '\0'; i = 0;
					if (k &amp; 1)
					{
						nd-&gt;value.children[nd-&gt;keys - 1]-&gt;type = STRING;
						nd-&gt;value.children[nd-&gt;keys - 1]-&gt;value.s_v = str;
					}
					else
					{
						JsonTrees *n = (JsonTrees *)malloc(sizeof(JsonTrees));
						memset(n-&gt;value.children, 0, sizeof(n-&gt;value.children));
						n-&gt;keys = 0;
						n-&gt;key = str;
						nd-&gt;value.children[nd-&gt;keys] = n;
					}
					k++;
				}
				  break;
		case ':': nd-&gt;keys++; break;
		case ',': break;
		case ' ': break;
		case '\n': break;
		default:  str[i++] = *s; break;
		}
		s++;
	}
	return r;
}
void parse2url(JsonTrees *pt, char *url_endings)
{
	int j = 0;
	for (int i = 0; i &lt; pt-&gt;keys; i++)
	{
		const char *ps = pt-&gt;value.children[i]-&gt;key;
		while (*ps)
			url_endings[j++] = *ps++;
		url_endings[j++] = '=';
		ps = pt-&gt;value.children[i]-&gt;value.s_v;
		while (*ps)
			url_endings[j++] = *ps++;
		url_endings[j++] = '&amp;';
	}
	url_endings[j - 1] = '\0';
}
void destory(struct JsonObj **prt, JsonTrees **pt)
{
	if (*pt)
	{
		for (int i = 0; i &lt; (*pt)-&gt;keys; i++)
			destory(prt, &amp;(*pt)-&gt;value.children[i]);
		free(*pt);
		if (*prt)
			free(*prt);
	}
}
int main()
{
	char str[] = "{\"Latin_Modern\":\"fn_lm\",\"Verdana\":\"fn_jvn\"}"; // "{\"Latin_Modern\":\"fn_lm\",\"Verdana\":\"fn_jvn\", \"Color\":[red,blue,green]}"
	char url_eds[SIZE];

	memset(url_eds, 0, sizeof(url_eds));
	JsonTrees *r = parse(str);
	parse2url(r, url_eds);
	printf("https://darkchii.cn/s/");
	puts(url_eds);
	getchar();
	return 0;
}
</code></pre>

<p>代码有个迷のbug，貌似每一个<code class="language-plaintext highlighter-rouge">children</code>的地址都被最后一个节点覆盖了，所以不管<code class="language-plaintext highlighter-rouge">key</code>or<code class="language-plaintext highlighter-rouge">value</code>都是最后一个字符串<code class="language-plaintext highlighter-rouge">fn_jvn</code>，但我没找到原因。</p>

<p>这颗树类似这样的建立方式：</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct T {
    T *next[3];
    int v;
};
struct P {
    T* root;
};
T*init()
{
    P *pt = (P*)malloc(sizeof(P));
    pt-&gt;root = (T*)malloc(sizeof(T));
    T *next_n;
    next_n = pt-&gt;root;
    for (int i = 0; i &lt; 3; i++)
    {
        T *n = (T*)malloc(sizeof(T));
        memset(n-&gt;next, 0, sizeof(n-&gt;next));
        n-&gt;v = i;
        next_n-&gt;next[i] = n;
    }
    return pt-&gt;root;
}
int main()
{
    T*head = init();
    for (int i = 0; i &lt; 3; i++)
    {
        printf("%d\n", head-&gt;next[i]-&gt;v);
    }
    return 0;
}
</code></pre>

<p>这样写没有任何问题。</p>
