{"pages":[{"title":"404","text":"404","path":"404/index.html","date":"07-08","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"07-12","excerpt":""},{"title":"about","text":"about me 更新于 2018-10-20 10:09:22 首先，非常感谢您的光顾，这里是一个还在不断探寻自我的人生初心者。自己实际上不太喜欢，也不太擅长展现真实的自己，但如果您还是想对我有所了解的话，那么可以看看下面的内容。可能会引起不适，慎阅。 。。。。。。。。 我是谁？一个没有自我的人，正因为如此便导致了这里有着如此迥异的风格，因为我也不知道自己是否真的喜欢这样一些东西，于是便把似乎大家都喜欢的样子混杂成这样，在一些动漫里，我这样的行为似乎是害怕被人嫌弃？嗯，我也不知道，但我的确渴望着一些东西。 正如您所见，我可能是一个心理有点问题的人，我自己也这么认为，之前的about me，让我自己看的一阵恶心，于是决定改掉。我总是这样，悄无声息的更改过去，让它变得让当前的自己看得下去一点，或许，不一会儿，这篇又将会被悄无声息的改掉。 我不知道自己是否真的喜欢计算机科学，虽然从接触它以来，自己短短的人生中为它也付出了许多，但自己并没能做到最好；我喜欢它，但却没有扎实一些重要的基础知识，只是做到了自己想知道的程度的刨根问底；我不喜欢它，但自己每天也都会思考一些程序；我真的喜欢/不喜欢吗，不好说。 我喜欢人吗？实际上，我是抗拒与他人接触的，因为我真的不喜欢自己。于是乎，这样就把锅甩给了全人类，擅自将自己代表人，我以为我是谁？我可真有脸说呢。但我本意并不是想代表他人，我只是不喜欢自己。许多书中也说到要爱自己，但我做不到。所以，或许，对于他人的安慰，我会感到厌恶。 如果这时候，抱怨世界的人问我喜欢这个世界吗，可能会辜负他的期望，我还是会说，我喜欢。因为我还有一些埋藏在内心深处的梦想，我还对这个世界、对美好的生活抱有期待，因为我见过了世间的美。 所以，我想我也是有真正喜欢的东西的。 如果非要我对自己做一个描述的话，我想我只是一个什么都不会、什么也没有，连普通人也算不上的、还在挣扎的不明物体吧。 但这些只不过是自己犯的错所导致的结果，只有结果是没有意义的。 所以，我想说一些原因。 我不知道看了下面这些的您会不会很讨厌我，我的确害怕一些东西会暴露自己，而让自己连同人交谈的资格也没有，但如果您想要再更多的了解这样的我，就有必要让您知道一个保质期还没过的真正的我。 我的高中只有黑历史。 不曾有过青春。 我对待亲人似乎很冷淡。 我不想听到她们的声音。 学习并不好。 我大二辍学了，所以目前也只是个高中生。 并不喜欢工作。 没勇气复读。 成为了废人。 离开了学校，才渐渐认识到，什么是青春、什么是学生时代。 嘛，也不是怀旧，也不是说人只有在那样的时光才能绽放光彩。 毕竟，我的那个学生时代，我想并不值得怀念。 也并没想要像向日葵田一样，在那时闪闪绽放。 只是，在那时没有好好做一个平凡的学生。 什么是平凡的学生？ 考虑着学习、升学的事请，每天普普通通的听着同学们的八卦，偶尔的与父母的争执、与异性青涩的互动。 但只是从那时起我的时间便早已停止了。 可能只有我…只有我的时间在那时便停止了。 但，他人依然在前进。不管道路是平坦、残缺、还是充满荆刺。 这是好的。 所以，我有点不舍。 只是这样。 谢谢阅读。","path":"about/index.html","date":"07-08","excerpt":""},{"title":"message","text":"","path":"message/index.html","date":"07-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-08","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"09-26","excerpt":""}],"posts":[{"title":"哈希树","text":"简介哈希树又叫做Merkle tree。广泛应用于密码学领域进行数据加密。个人也很喜欢这个算法。 数据结构一张十分易懂的图(来源：https://blog.csdn.net/yang_yulei/article/details/46337405) ： 1234template&lt;class T1, class T2&gt; struct BaseNode &#123; T1 key; T2 val; BaseNode*next[N];&#125; 加权函数由于key数据主要使用字符串类型，所以我们先考虑将字符串进行加权。沿用了我做Json解析器时用到的加权函数。稍有不同的是，这里直接使用每一个字符的ascii码乘以字符的位置，最后再加上字符串长度。因为考虑到数字类的字符的ascii码比字符A小，会出现负数。设字符串长度为 $ n $，则加权函数为 weight(s) = n + \\sum_{i = 0}^{n} s_{i} \\cdot (i + 1)即 123456ll weight(string key)&#123; ll x = 0; size_t i = 0; for (; i &lt; key.size(); i++) x += key[i]*(i + 1); return x + i;&#125; 算法解析显然，树由上而下变得越来越茂密，因为，根据质数的性质，如果质数越小，则能被其整除的数越多，所以，发生碰撞的概率越大，于是这样就导致了树的形状。关于为什么质数只使用到 $ 29 $，每一层的子节点数最大为 $ 32 $ 的问题，我认为看严谨的数学证明会更好：https://wenku.baidu.com/view/16b2c7abd1f34693daef3e58.html ps 还是想说说算法的空间复杂度：第0层1个根节点，第1层为2进制，第0层最多2个子节点，第2层为3进制，每个节点最多3个子节点，第3层为5进制，每个节点最多5个子节点。。。以此类推，注意到每一层的总结点个数为以该层的进制数为底，前一层的进制数为幂，因此最坏情况下，10层的时候，哈希树的总空间大小为：$ 2^1 + 3^2 + 5^3 + 7^5 + 11^7 + 13^{11} + 17^{13} + 19^{17} + 23^{19} + 29^{23} $ 这是一个非常大的数字，所以空间是完全足够的。至于32，每层每个节点都有32个子节点的空间，最大可以 $ mod \\ 29 $，所以，下标也不会越界。想要突破第十层，需要比较特殊的一组数，可以连续映射前 10 个质数。其实也很容易突破，只要这组数满足第 $ i $ 个数能被前 $ i $ 个质数整除，就可以了（我之前的加权算法会导致这样的情况，比如，这样一组字符串 “a”,”b”,”c”,”d”，虽然字符串不同，但却都被加权为1，结果 $ 1 \\ mod $ 任何数都为1，嘛…后来改为下标从 1 开始就不存在单个字符组成的字符串被加权为 1 的情况了）。但工程中也尽量避免这样的情况，会做一些处理，所以基本上属于概率问题了。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;#define ll long long#define MAX_OVERFLOW 0x16using namespace std;const int N = 32;const int prime[] = &#123; 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 &#125;;template&lt;class T&gt;ll weight(T key)&#123; ll x = 0; size_t i = 0; for (; key[i]; i++) x += key[i]*(i + 1); return x + i;&#125;template&lt;class T1, class T2&gt; struct BaseNode &#123; T1 key; T2 val; unsigned short floor; BaseNode*next[N]; BaseNode() &#123; floor = 0; REP(i, N) next[i] = nullptr; &#125; BaseNode(T1 k, T2 v) : key(k), val(v) &#123; floor = 0; REP(i, N) next[i] = nullptr; &#125;&#125;;template&lt;class T1, class T2&gt;class HashTree &#123;private: T2 return_type_value; BaseNode&lt;T1, T2&gt;*root; void destory(BaseNode&lt;T1, T2&gt;*&amp;r) &#123; if (r) &#123; REP(i, prime[r-&gt;floor]) destory(r-&gt;next[i]); delete r; &#125; &#125; void print(BaseNode&lt;T1, T2&gt;*&amp;r) &#123; if (r) &#123; REP(i, prime[r-&gt;floor]) print(r-&gt;next[i]); cout &lt;&lt; r-&gt;key &lt;&lt; \":\" &lt;&lt; r-&gt;val &lt;&lt; endl; &#125; &#125; BaseNode&lt;T1, T2&gt;* findkey(T1 key) &#123; BaseNode&lt;T1, T2&gt;*p = root; if (p) &#123; size_t i = 0; while (p &amp;&amp; p-&gt;key != key) p = p-&gt;next[weight(key)%prime[i++]]; return p; &#125; return nullptr; &#125;public: HashTree() &#123; root = nullptr; if (typeid(T2) == typeid(string)) return_type_value = string(\"\"); else if (typeid(T2) == typeid(const char*)) return_type_value = \"\"; else if (typeid(T2) == typeid(char*)) return_type_value = \"\"; else if (typeid(T2) == typeid(long long)) return_type_value = MAX_OVERFLOW; else if (typeid(T2) == typeid(int)) return_type_value = ~MAX_OVERFLOW | 1; else if (typeid(T2) == typeid(unsigned)) return_type_value = MAX_OVERFLOW &gt;&gt; 1 | 1; else if (typeid(T2) == typeid(short)) return_type_value = ~MAX_OVERFLOW &gt;&gt; 1; else if (typeid(T2) == typeid(double)) return_type_value = MAX_OVERFLOW | 1; else if (typeid(T2) == typeid(float)) return_type_value = MAX_OVERFLOW &gt;&gt; 1 | 1; else if (typeid(T2) == typeid(bool)) return_type_value = false; else return_type_value = nullptr; &#125; HashTree(T1 k, T2 v) &#123; root = nullptr; insert(k, v); &#125; ~HashTree() &#123; destory(root); &#125; void insert(T1 key, T2 val) &#123; BaseNode&lt;T1, T2&gt;*n = new BaseNode&lt;T1, T2&gt;(key, val); if (!root) root = n; else &#123; if (!findkey(key)) &#123; BaseNode&lt;T1, T2&gt;*p = root; size_t i = 0; while (p-&gt;next[weight(key)%prime[i]]) p = p-&gt;next[weight(key)%prime[i++]]; n-&gt;floor = i + 1; p-&gt;next[weight(key)%prime[i]] = n; &#125; &#125; &#125; void update(T1 key, T2 val) &#123; BaseNode&lt;T1, T2&gt;*p = findkey(key); if (p) p-&gt;val = val; else &#123; cerr &lt;&lt; \"Not found the key!\" &lt;&lt; endl; return; &#125; &#125; void remove(T1 key) &#123; BaseNode&lt;T1, T2&gt;*p = findkey(key); if (p) &#123; size_t i = 0, pos; while (!p-&gt;next[i++]) /* pass */; pos = i - 1; queue&lt;BaseNode&lt;T1, T2&gt;*&gt; children; while (i &lt; prime[p-&gt;next[pos]-&gt;floor - 1]) &#123; if (p-&gt;next[i]) children.push(p-&gt;next[i]); i++; &#125; p = p-&gt;next[pos]; delete p; while (!children.empty()) &#123; BaseNode&lt;T1, T2&gt;*siling = children.front(); children.pop(); BaseNode&lt;T1, T2&gt;*n = p; size_t j = siling-&gt;floor; while (p-&gt;next[weight(siling-&gt;key)%prime[j]]) p = p-&gt;next[weight(siling-&gt;key)%prime[j++]]; p-&gt;next[weight(siling-&gt;key)%prime[j]] = siling; &#125; &#125; else &#123; cerr &lt;&lt; \"Not found the key!\" &lt;&lt; endl; return; &#125; &#125; void visual() &#123; print(root); &#125; T2&amp; GetValue(T1 key) &#123; BaseNode&lt;T1, T2&gt;*n = findkey(key); if (n) return n-&gt;val; cerr &lt;&lt; \"Not found the key!\" &lt;&lt; endl; return return_type_value; &#125; T2&amp; operator[](T1 key) &#123; return GetValue(key); &#125; T2&amp; operator=(T2 val) &#123; return val; &#125;&#125;;int main()&#123; HashTree&lt;string, string&gt; n; n.insert(\"one\", \"first\"); n.insert(\"two\", \"second\"); n.insert(\"three\", \"third\"); n.insert(\"four\", \"fourth\"); n.insert(\"five\", \"fifth\"); n.insert(\"six\", \"sixth\"); cout &lt;&lt; n[\"two\"] &lt;&lt; endl; cout &lt;&lt; n[\"three\"] &lt;&lt; endl; cout &lt;&lt; n[\"one\"] &lt;&lt; endl; n[\"one\"] = \"error\"; // 还可以通过这样的方式进行赋值 cout &lt;&lt; n[\"one\"] &lt;&lt; endl; n.visual(); return 0;&#125; output: 12345678910secondthirdfirsterrorsix:sixthfive:fifththree:thirdtwo:secondfour:fourthone:error","path":"2018/09/28/hash-tree/","date":"09-28","excerpt":""},{"title":"后缀树","text":"前言详见我的这篇blog:Suffix tree 路径压缩版后缀树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;using namespace std;#define rep(i, a, b) for(int i = a; i &lt; b; i++)#define trans(c) (c - 'a')#define SIZE 26#define MAX (100010 &lt;&lt; 2)struct BaseNode &#123; int len; const char*s; int pos[MAX]; BaseNode*next[SIZE]; BaseNode() &#123; len = 0; rep(i, 0, MAX) pos[i] = 0; rep(i, 0, SIZE) next[i] = nullptr; &#125; BaseNode(const char*s, int p) &#123; this-&gt;s = s, this-&gt;len = p; rep(i, 0, MAX) pos[i] = 0; rep(i, 0, SIZE) next[i] = nullptr; &#125;&#125;;class SuffixTree &#123;private: BaseNode*root; /**/ void add(const char*s, int p); void print(BaseNode*r); void destory(BaseNode*&amp;r);public: SuffixTree() &#123; root = nullptr; &#125; void insert(const char*s); void insert(string s) &#123; insert(s.c_str()); &#125; void remove(const char*s) &#123; &#125; void visual() &#123; print(root); &#125; bool match(const char*s); bool match(string s) &#123; match(s.c_str()); &#125; ~SuffixTree() &#123; destory(root); &#125;&#125;;void SuffixTree::add(const char*s, int p)&#123; int i = 0; while (s[i]) i++; if (!root-&gt;next[p]) root-&gt;next[p] = new BaseNode(s, i); root-&gt;next[p]-&gt;pos[i] = i;&#125;void SuffixTree::insert(const char*s)&#123; root = new BaseNode(); while (*s) &#123; add(s, trans(*s)); s++; &#125;&#125;bool SuffixTree::match(const char*s)&#123; const char* ps = root-&gt;next[trans(*s)]-&gt;s; while (*s) if (*ps++ != *s++) return false; return true;&#125;void SuffixTree::print(BaseNode*r)&#123; if (r) &#123; rep(i, 0, SIZE) if (r-&gt;next[i]) &#123; cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; endl; rep(j, 0, r-&gt;next[i]-&gt;len + 1) if (r-&gt;next[i]-&gt;pos[j]) &#123; rep(k, 0, r-&gt;next[i]-&gt;pos[j]) cout &lt;&lt; r-&gt;next[i]-&gt;s[k]; cout &lt;&lt; '$' &lt;&lt; endl; &#125; &#125; &#125;&#125;void SuffixTree::destory(BaseNode*&amp;r)&#123; if (r) &#123; rep(i, 0, SIZE) destory(r-&gt;next[i]); delete r; &#125;&#125;int main()&#123; SuffixTree st; st.insert(\"banana\"); st.visual(); if (st.match(\"na\")) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125; output: 123456789100:a$ana$anana$1:banana$13:na$nana$Yes","path":"2018/09/25/suffix-tree/","date":"09-25","excerpt":""},{"title":"浮点型转字符串","text":"前言写 Json 解析器的时候临时写了一个字符串转浮点型的算法（详见Json 解析器中的代码str2float()函数），写的时候一边又想了浮点型转字符串的算法。但还有一些 bug 和没注意到的地方，比如，小数点后全是 0，正确的做法是要把所有 0 都表示出来，小数点后的某两个数不为 0 的数之间出现 0，会在末尾多出一个‘(’符。 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;const int N = 100010;char s[N];void bits(char str[], int &amp;i, int x)&#123; if (!x) return ; bits(str, i, x/10); str[i++] = x%10 + '0';&#125;char* dou2str(double num)&#123; int i = 0; if (num &lt; 0) s[i++] = '-', num *= -1; int x = num; double y = num - x; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1)%10 + '0'; // &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;int main()&#123; double num = 123204.00657; cout &lt;&lt; dou2str(num) &lt;&lt; endl; return 0;&#125; 算法释义对于小数点左边的部分处理，显然，使用递归是最方便的。 重点部分是处理小数部分的精度，计算机会将比如浮点数 0.54 = 0.53999999999，于是当小数点移到 54 时，就会变为 53.99999999，这时 int 会得到 53，然后就不能得到精确结果了。所以对每个移动小数点后的数都 +0.1来判断可以避免这个问题。我的出口判断条件是当小数点移动到某个位置时，如果向上取整的数等于向下取整的数，就说明这个数以后都是 0 了，那么循环就到此结束。","path":"2018/09/25/float-to-string/","date":"09-25","excerpt":""},{"title":"P3372（模板）线段树1","text":"代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define MP make_pair#define PB push_back#define st first#define nd second#define rd third#define rg register#define FOR(i, a, b) for(int i =(a); i &lt;=(b); ++i)#define RE(i, n) FOR(i, 1, n)#define FORD(i, a, b) for(int i = (a); i &gt;= (b); --i)#define REP(i, n) for(int i = 0;i &lt;(n); ++i)#define VAR(v, i) __typeof(i) v=(i)#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) ((int)(x).size())using namespace std;#define l(i) ((i) &lt;&lt; 1)#define r(i) ((i) &lt;&lt; 1 | 1)const int N = 500010;struct &#123; int l, r, val, tag; &#125; segment[N];inline int read()&#123; char c; int ret = 0, sgn = 1; do&#123;c = getchar();&#125;while((c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); if(c == '-') sgn = -1; else ret = c - '0'; while((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0'); return sgn * ret;&#125;void build(int num[], int s, int e, int p)&#123; if (s == e) segment[p].val = num[s]; else &#123; segment[p].tag = 0; int m = (s + e) &gt;&gt; 1; build(num, s, m, l(p)); build(num, m + 1, e, r(p)); segment[p].val = segment[l(p)].val + segment[r(p)].val; &#125;&#125;void update(int s, int e, int b, int f, int p, int v)&#123; if (b &lt;= s &amp;&amp; e &lt;= f) &#123; segment[p].val += v*(e - s + 1); segment[p].tag += v; return; &#125; int m = (s + e) &gt;&gt; 1; segment[l(p)].tag += segment[p].tag; segment[l(p)].val += segment[p].tag*(m - s + 1); segment[r(p)].tag += segment[p].tag; segment[r(p)].val += segment[p].tag*(e - m); segment[p].tag = 0; if (b &lt;= m) update(s, m, b, f, l(p), v); if (f &gt; m) update(m + 1, e, b, f, r(p), v); segment[p].val = segment[l(p)].val + segment[r(p)].val;&#125;int query(int s, int e, int b, int f, int p)&#123; if (b &lt;= s &amp;&amp; e &lt;= f) return segment[p].val; int m = (s + e) &gt;&gt; 1, ans = 0; segment[l(p)].tag += segment[p].tag; segment[l(p)].val += segment[p].tag*(m - s + 1); segment[r(p)].tag += segment[p].tag; segment[r(p)].val += segment[p].tag*(e - m); segment[p].tag = 0; if (b &lt;= m) ans += query(s, m, b, f, l(p)); if (f &gt; m) ans += query(m + 1, e, b, f, r(p)); return ans;&#125;int main()&#123; int n, m, num[N], x, y, v, opera; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; num[i]; build(num, 1, n, 1); while (m--) &#123; cin &gt;&gt; opera; switch(opera) &#123; case 1: cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; update(1, n, x, y, 1, v); break; case 2: cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, n, x, y, 1) &lt;&lt; endl; break; &#125; &#125; return 0;&#125;","path":"2018/09/24/p3372/","date":"09-24","excerpt":""},{"title":"P3368（模板）树状数组","text":"前言借这个题学新姿势，这个题需要利用差分才能AC，普通树状树有3个点过不了。 差分原理（参考题解区大佬）：一个例子，一组数据 $ a[] = { 1, 5, 4, 2, 3 } $，差分后得到 $ b[] = { 1, 4, -1, -2, 1 } $，其中 $ a_0 = 0, b_i = a_i - a_{i - 1} $，求原数组 $ a_n $ 某个位置 $ i $ 上的值。 由 $ b_i = a_i - a_{i - 1} \\Rightarrow a_i = b_i + a_{i - 1} $，于是 \\left. \\begin{aligned} a_i &= b_i + a_{i - 1} \\\\ a_{i - 1} &= b_{i - 1} + a_{i - 2} \\\\ \\vdots \\\\ a_1 &= b_1 + a_0 \\end{aligned} \\right \\} +\\Rightarrow a_i = b_i + b_{i - 1} + \\cdots + b_1 + a_0注意到 $ a_0 = 0 $，于是 $ a_i = \\sum_{i = 1}^{n} b_i $ 。这样就求出了原数组位置上的值了。 然后再看看如何更新区间的值呢。 我们对 a 数组区间 2 ~ 4 每个值进行 +2 操作，得到 $ 1, 7, 6, 4, 3 $，我们对这个数组进行新的差分得到 $ b_n’ = { 1 6 -1 -2 -1 } $ ，我们比较新的差分数组 $ b_n’ $ 与 $ b_n $，发现只有 $ b_2’, b_5’ $ 上的值变了，$ b_2’ = b_2 + 2, b_5’ = b_5 - 2 $，可以验证，在任何区间 $ a[l,…,r] $ 做出 $ +x $ 更新，都有 $ b_l’ = b_l + x , b_{r + 1}’ = b_{r + 1} - x $ 。并且不论任何数组经过这样操作都有这样的特点，于是就有了代码中的 dif() 函数对区间进行更新。这样每次更新只用更新位置 $ b_l, b_{r + 1} $ 上的值，效率提高了许多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MP make_pair#define PB push_back#define st first#define nd second#define rd third#define rg register#define FOR(i, a, b) for(int i =(a); i &lt;=(b); ++i)#define RE(i, n) FOR(i, 1, n)#define FORD(i, a, b) for(int i = (a); i &gt;= (b); --i)#define REP(i, n) for(int i = 0;i &lt;(n); ++i)#define VAR(v, i) __typeof(i) v=(i)#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)#define ALL(x) (x).begin(), (x).end()#define SZ(x) ((int)(x).size())using namespace std;#define lowbit(x) ((x) &amp; (-x))const int N = 500010;int id[N];void upd(int n, int k, int x)&#123; while (k &lt;= n) id[k] += x, k += lowbit(k);&#125;void dif(int n, int l, int r, int x)&#123; upd(n, l, x); upd(n, r + 1, -x);&#125;int sum(int k)&#123; int ans = 0; while (k &gt; 0) ans += id[k], k -= lowbit(k); return ans;&#125;int org(int k)&#123; return sum(k) - sum(k - 1);&#125;int ask(int l, int r)&#123; return sum(r) - sum(l - 1);&#125;int main()&#123; int n, m, k, x, opera, l, r, pre; pre = 0; cin &gt;&gt; n &gt;&gt; m; FOR (i, 1, n) &#123; cin &gt;&gt; x; upd(n, i, x - pre); // 差分后更新到树状数组 pre = x; &#125; while(m--) &#123; cin &gt;&gt; opera; switch(opera) &#123; case 1: cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; dif(n, l, r, x); break; case 2: cin &gt;&gt; k; cout &lt;&lt; sum(k) &lt;&lt; endl; break; &#125; &#125; return 0;&#125;","path":"2018/09/19/p3368/","date":"09-19","excerpt":""},{"title":"筛法","text":"Sieve of Eratosthenes (埃氏筛)时间复杂度：$ O(nlglgn) $ 埃氏筛 - 维基百科 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000010;int main(int n, char**v)&#123; bool prime[N]; for(int i = 2; i &lt; N; i++) prime[i] = true; for (int i = 2; i &lt;= sqrt(N); i++) if (prime[i]) for (int j = i*i; j &lt; N; j += i) prime[j] = false; for (int i = 2; i &lt; N; i++) if (prime[i]) cout &lt;&lt; i &lt;&lt; ' '; return 0;&#125; Sieve of AtkinSieve of Atkin - wikipedia Sieve of prime (素数筛)学会这个筛法就可以A掉这个题了：P3383 【模板】线性筛 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define rg registerconst int N = 10000010;int prime[N], notprime[N];void SievePrime()&#123; int step = 0; notprime[1] = 1; for (rg int i = 2; i &lt; N; i++) &#123; if (!notprime[i]) prime[++step] = i; for (rg int j = 1; j &lt;= step &amp;&amp; prime[j] * i &lt; N; j++) &#123; notprime[i * prime[j]] = 1; if (i%prime[j] == 0) break; &#125; &#125;&#125;int main()&#123; SievePrime(); for (rg int i = 0; i &lt; N; i++) if (prime[i]) cout &lt;&lt; prime[i] &lt;&lt; ' '; return 0;&#125; Sieve of Euler (欧拉筛)原理欧拉函数 \\phi(n) = n \\prod_{p|n} (1 - \\frac{1}{p}) = \\prod(p - 1)p^{k_r - 1}其中 $ p $ 为 $ n $ 的所有质因子。它表示在不超过 $ n $ 的正整数中与 $ n $ 互质的数的个数。 如果 $ p $ 是素数，$ k \\geq 1 $，那么有 \\phi(p^k) = p^{k - 1}(p - 1) = p^k(1 - \\frac{1}{p})利用这个公式便可以证明欧拉函数。 首先 $ n = p_1^{k_1} \\cdots p_r^{k_r} $，则 \\begin{aligned} \\phi(n) &= \\phi(p_1^{k_1})\\phi(p_2^{k_2}) \\cdots \\phi(p_r^{k_r}) \\\\ &= p_1^{k_1}(1 - \\frac{1}{p_1})p_2^{k_2}(1 - \\frac{1}{p_2}) \\cdots p_r^{k_r}(1 - \\frac{1}{p_r}) \\\\ &= p_1^{k_1}p_2^{k_2} \\cdots p_r^{k_r}(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2}) \\cdots (1 - \\frac{1}{p_r}) \\\\ &= n(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2}) \\cdots (1 - \\frac{1}{p_r}) \\end{aligned}欧拉函数是积性函数。 与欧拉定理、费马小定理的关系 对任何两个互质的正整数 $ a, m (m &gt;= 2) $，有欧拉定理 $ a^{\\phi(m)} = 1(mod \\ m) $ (其中 $ \\phi(m) $ 是欧拉函数) ，当 $ m $ 是质数 $ p $ 时，式子变为 x^{p - 1} = 1(mod \\ p)即费马小定理。 更多关于欧拉函数，另请参见： 欧拉函数 - 百度百科 Euler function - wikipedia 求欧拉函数的算法 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int eular(int n)&#123; int ret=1; for(int i = 2; i*i &lt;= n; i++) &#123; if(n%i == 0) &#123; n /= i,ret *= i - 1; while(n%i == 0) n /= i, ret *= i; &#125; &#125; if(n &gt; 1) ret *= n - 1; return ret;&#125;int main()&#123; int n, s; cin &gt;&gt; n; s = eular(n); cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 欧拉筛法 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define rg registerconst int N = 10000010;int prime[N], notprime[N], phi[N];void SieveEuler()&#123; int step = 0; phi[1] = 1; for (rg int i = 2; i &lt; N; i++) &#123; if (!notprime[i]) prime[++step] = i, phi[i] = i - 1; for (rg int j = 1; j &lt;= step &amp;&amp; prime[j] * i &lt; N; j++) &#123; notprime[i * prime[j]] = 1; if (i%prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i]*(prime[j] - 1); &#125; &#125;&#125;int main()&#123; SieveEuler(); for (rg int i = 0; i &lt; N; i++) if (prime[i]) cout &lt;&lt; prime[i] &lt;&lt; ' '; return 0;&#125; Sieve of Mobius (莫比乌斯筛)原理莫比乌斯函数 \\mu(n) = \\eta_{\\omega(n)\\Omega(n)}\\lambda(n)这里 $ \\lambda(n) $ 是刘维尔函数。 莫比乌斯函数也是一个积性函数（$ \\mu(ab) = \\mu(a)\\mu(b) $，$ a $ 和 $ b $ 互质 ） 当 $ n = 1 $ 时，$ n $ 的所有因子的莫比乌斯函数值和为 1;当 $ n \\neq 1 $ 时，$ n $ 的所有因子的莫比乌斯函数值和为 0. 即 \\sum_{d|n}\\mu(d) = \\left\\{ \\begin{aligned} 1 \\quad n = 1; \\\\ 0 \\quad n > 1. \\end{aligned} \\right.莫比乌斯函数完整定义的通俗表达： 莫比乌斯函数 $ \\mu(n) $ 的定义域是 $ N $; $ \\mu(1) = 1 $; 当n存在平方因子时，$ \\mu(n) =0 $; 当n是素数或奇数个不同素数之积时，$ \\mu(n) = -1 $; 当n是偶数个不同素数之积时，$ \\mu(n) = 1 $. \\mu(n) = \\left\\{ \\begin{aligned} 1 \\quad n = 1; \\\\ (-1)^k \\quad n = p_1 p_2 \\ cdots p_k 0 \\quad other. \\end{aligned} \\right.参考： 莫比乌斯函数 - 百度百科Mobius function - wikipedia 莫比乌斯筛法 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define rg registerconst int N = 1000010;int prime[N], notprime[N], mobius[N];void SieveMobius()&#123; int step = 0; mobius[1] = 1; for (rg int i = 2; i &lt; N; i++) &#123; if (!notprime[i]) prime[++step] = i, mobius[i] = -1; for (rg int j = 1; j &lt;= step &amp;&amp; prime[j] * i &lt; N; j++) &#123; notprime[i * prime[j]] = 1; if (i%prime[j] == 0) &#123; mobius[i * prime[j]] = 0; break; &#125; else mobius[i * prime[j]] = -mobius[i]; &#125; &#125;&#125;int main()&#123; SieveMobius(); for (int i = 0; i &lt; N; i++) if (prime[i]) cout &lt;&lt; prime[i] &lt;&lt; ' '; return 0;&#125; 其他参考线性筛几种线性筛","path":"2018/09/13/sieve/","date":"09-13","excerpt":""},{"title":"计数排序","text":"简介计数排序是一种空间换时间的排序算法。通常用作基数排序的子过程。 参考文献 Counting sort - wikipeida 计数排序 - 百度百科 Counting sort - geeksforgeeks 算法实现12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int MAXN = 100000;const int k = 1000;int a[MAXN], c[MAXN], ranked[MAXN];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; ++c[a[i]]; &#125; for (int i = 1; i &lt; k; ++i) c[i] += c[i - 1]; for (int i = n - 1; i &gt;= 0; --i) ranked[--c[a[i]]] = a[i]; for (int i = 0; i &lt; n; ++i) cout &lt;&lt; ranked[i] &lt;&lt; ' '; return 0;&#125; 算法分析 时间复杂度 O(n + k) 空间复杂度 O(n + k)","path":"2018/09/09/counting-sort/","date":"09-09","excerpt":""},{"title":"矩阵运算","text":"简介这篇主要介绍一些矩阵运算相关算法。 矩阵乘法矩阵相乘：$ C = AB $ 普通算法 时间复杂度 $ O(N^3) $ 12345memset(c, 0, sizeof(c));for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) for (int k = 0; k &lt; N; k++) c[i][j] += a[i][k] * b[k][j]; Strassen算法 时间复杂度 $ O(N^{lg7}) $ 123void Strassen_algo(vector&lt;vector&lt;float&gt;&gt; &amp; c, vector&lt;vector&lt;float&gt;&gt; a, vector&lt;vector&lt;float&gt;&gt; b)&#123;&#125; 线性方程组$ n $ 个未知数 $ m $ 个方程的线性方程组 \\left\\{ \\begin{matrix} a_{00}x_0 & a_{01}x_1 & \\cdots & a_{0n}x_n &= b_0 \\\\ a_{10}x_0 & a_{11}x_1 & \\cdots & a_{1n}x_n &= b_1 \\\\ \\vdots \\\\ a_{m0}x_0 & a_{m1}x_1 & \\cdots & a_{mn}x_n &= b_m \\end{matrix}\\right.将上式写为以向量 $ x $ 为未知元的向量方程 Ax = b \\quad (1)方程是否有解设 $ B = (A, b) $ 为增广矩阵，$ R(A) $ 是矩阵 $ A $ 的秩，$ R(A, b) $ 是增广矩阵 $ B $ 的秩。 无解的充分必要条件是 $ R(A) &lt; R(A, b) $; $ n $ 元线性方程组 $ Ax = b \\quad $ 有唯一解的充分必要条件是 $ R(A) = R(A, b) = n $; 有无限多解的充分必要条件是 $ R(A) = R(A, b) \\leq n $. LUP分解原理$ LUP $ 分解的基本思想就是找出三个 $ n \\times n $ 矩阵 $ L $、$ U $、$ P $，满足 PA = LU \\quad (2)其中，$ L $ 是一个单位下三角矩阵，$ U $ 是一个上三角矩阵，$ P $ 是一个置换矩阵。我们称满足式 (2) 的矩阵 $ L $、$ U $、$ P $ 为矩阵 $ A $ 的 LUP 分解。 可以证明，如果矩阵 $ A $ 是一个非奇异矩阵，那么我们一定能找到 $ L $、$ U $、$ P $ 分解满足上式。 这有什么用呢？ 我们先对 (1) 进行置换，在等式 $ Ax = b $ 两边同时乘以 $ P $ 置换，得到：$ PAx = Pb $，利用 (2) 式有 LUx = Pb设 $ y = Ux $，其中 x 就是要求解的向量解。首先，通过一种称为“正向替换”的方法求解单位下三角系统 Ly = Pb \\quad (3)得到未知向量 $ y $。然后，通过一种称为“反向替换”的方法求解上三角系统 Ux = y \\quad (4)得到向量解 $ x $。由于置换矩阵 $ P $ 是可逆的，在等式 (2) 两边同时乘以 $ P^{-1} $，于是 A = P^{-1}LU因此，向量 $ x $ 就是 $ Ax = b $ 的解 \\begin{aligned} Ax &= P^{-1}LUx \\\\ &= P^{-1}Ly \\\\ &= P^{-1}Pb \\\\ &= b \\end{aligned}正向替换与反向替换进一步看看正向替换与反向替换是如何进行的。 正向替换 已知 $ L $、$ P $ 和 $ b $，正向替换可在 $ O(n^2) $ 的时间内求解单位下三角系统 (3)。 Pb = \\begin{bmatrix} p_{0,0} & p_{0,1} & \\cdots & p_{0,n} \\\\ p_{1,0} & p_{1,1} & \\cdots & p_{1,n} \\\\ \\vdots & \\vdots & \\cdots & \\vdots \\\\ p_{n,0} & p_{n,1} & \\cdots & p_{n,n} \\end{bmatrix} \\begin{bmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} = \\begin{bmatrix} \\sum_{j = 0}^{n}p_{0,j} \\cdot b_j \\\\ \\sum_{j = 0}^{n}p_{1,j} \\cdot b_j \\\\ \\vdots \\\\ \\sum_{j = 0}^{n}p_{n,j} \\cdot b_j \\end{bmatrix}为了方便起见，这里用一个数组 $ \\pi[0…n] $ 简洁地表示置换 $ P $。对 $ i = 0, 1, 2, \\cdots, n $，元素 $ \\pi[i] $ 表示 $ P_{i, \\pi[i]} = 1 $，并且对 $ j \\neq \\pi[i] $ 有 $ P_{ij} = 0 $。因此，$ PA $ 第 $ i $ 行第 $ j $ 列的元素为 $ a_{\\pi[i],j} $，$ Pb $ 的第 $ i $ 个元素为 $ b_{\\pi[i]} $。因为 $ L $ 是单位下三角矩阵，我们可以重写等式 (3) 为： \\begin{bmatrix} y_0 & & & & & & & & &= b_{\\pi[0]} \\\\ l_{10}y_0 & + & y_1 & & & & & & &= b_{\\pi[1]} \\\\ l_{20}y_0 & + & l_{21}y_1 & + & y_2 & & & & &= b_{\\pi[2]} \\\\ \\vdots \\\\ l_{n0}y_0 & + & l_{n1}y_1 & + & l_{n2}y_2 & + & \\cdots & + & y_n &= b_{\\pi[n]} \\end{bmatrix}第一个等式可以求出 $ y_0 $，我们把它代入第二个等式，求出 y_1 = b_{\\pi[1]} - l_{10}y_0在将 $ y_1, y_2 $ 代入第三个等式，得到 y_2 = b_{\\pi[2]} - (l_{20}y_0 + l{21}y_1)一般的，我们把 $ y_0, y_1, \\cdots, y_{i - 1} $ “正向替换”到第 $ i $ 个等式中，就可以求解 $ y_i $： y_i = b_{\\pi[i]} - \\sum_{j = 0}^{i - 1} l_{ij}y_{j} 反向替换 与正向替换类似，求解上三角系统等式 (4)。 \\begin{bmatrix} u_{0,0}x_0 & + & u_{0,1}x_1 & + & \\cdots & + & u_{0,n-2}x_{n-2} & + & u_{0,n-1}x_{n-1} & + & u_{0,n}x_n &= y_{0} \\\\ & & u_{1,1}x_1 & + & \\cdots & + & u_{1,n-2}x_{n-2} & + & u_{1,n-1}x_{n-1} & + & u_{1,n}x_n &= y_{1} \\\\ & & & & & & & & & & \\vdots \\\\ & & & & & & u_{n-2,n-2}x_{n-2} & + & u_{n-2,n-1}x_{n-1} & + & u_{n-2,n}x_n &= y_{n - 2} \\\\ & & & & & & & & u_{n-1,n-1}x_{n-1} & + & u_{n-1,n}x_n &= y_{n - 1} \\\\ & & & & & & & & & & u_{n,n}x_n &= y_{n} \\end{bmatrix}这里我们先求解第 $ n $ 个等式，然后往前一个等式代，因此可以如下相继求出 $ x_n, x_{n - 1}, \\cdots, x_1 $ 的解： \\begin{aligned} x_n &= \\frac{y_{n}}{u_{n,n}} \\\\ x_{n - 1} &= \\frac{y_{n - 1} - u_{n - 1, n}x_n}{u_{n - 1,n - 1}} \\\\ \\vdots \\end{aligned}一般的，有 x_i = \\frac{y_i - \\sum_{j = i + 1}^{n} u_{ij}x_{j}}{u_{ij}}计算LUP分解我们该如何找到这样的 $ L $、 $ U $、 $ P $ 矩阵呢？ 通常在 $ LUP $ 分解中包含一个置换矩阵 $ P $ 的原因是为了避免矩阵 $ A $ 中的主元 $ a_{i,i} = 0 $ ，即矩阵对角线上的数。 但如果矩阵 $ A $ 的对角线上的数都不为 0，我们有一个 $ LU $ 分解算法就可以计算出矩阵 $ L $ 、 $ U $。 下面先给出LU分解算法的实现，之后再分析算法原理。 LU分解算法实现示例(Example): \\begin{bmatrix} 2 & 3 & 1 & 5 \\\\ 6 & 13 & 5 & 19 \\\\ 2 & 19 & 10 & 23 \\\\ 4 & 10 & 11 & 31 \\\\ \\end{bmatrix}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;const int N = 4;using namespace std;void lu(vector&lt;vector&lt;float&gt;&gt; &amp;l, vector&lt;vector&lt;float&gt;&gt; &amp;u, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; l[i][i] = 1; for (int j = i + 1; j &lt; N; j++) l[i][j] = 0; &#125; for (int i = 1; i &lt; N; i++) for (int j = 0; j &lt; i; j++) u[i][j] = 0; for (size_t i = 0; i &lt; N; i++) &#123; u[i][i] = a[i][i]; for (size_t j = i + 1; j &lt; N; j++) &#123; l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; &#125; for (size_t j = i + 1; j &lt; N; j++) for (size_t k = i + 1; k &lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; &#125;&#125;int main()&#123; vector&lt;vector&lt;float&gt;&gt; l(N, vector&lt;float&gt;(N)); vector&lt;vector&lt;float&gt;&gt; u(N, vector&lt;float&gt;(N)); float a[N][N] = &#123; 2, 3, 1, 5, 6, 13, 5, 19, 2, 19, 10, 23, 4, 10, 11, 31 &#125;; lu(l, u, a); cout &lt;&lt; \"L 矩阵:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) cout &lt;&lt; l[i][j] &lt;&lt; '\\t'; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"U 矩阵:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) cout &lt;&lt; u[i][j] &lt;&lt; '\\t'; cout &lt;&lt; endl; &#125; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) for (int k = 0; k &lt; N; k++) a[i][j] += l[i][k] * u[k][j]; cout &lt;&lt; \"A 矩阵:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) cout &lt;&lt; a[i][j] &lt;&lt; '\\t'; cout &lt;&lt; endl; &#125; return 0;&#125; LU分解算法分析前面说到对于一个非奇异矩阵 $ A $，即 $ \\det{A} \\neq 0 $，就能找到其 $ LU $ 分解，那么运用正向替换与反向替换就可以求出线性方程组 $ Ax = b $ 的解。 原理：算法利用高斯消元法来创建 $ LU $ 分解。首先从其他方程中减去第一个方程的倍数，以把那些方程中的第一个变量消去。然后，从第三个及以后的方程中减去第二个方程的倍数，把这些方程的第一个和第二个变量消去。继续上述过程，直到系统变为一个上三角矩阵形式，实际上此矩阵就是 $ U $。矩阵 $ L $ 是由消去变量所用的行的乘数组成。 采用递归算法实现这个策略。我们希望构造出一个 $ n \\times n $ 的非奇异矩阵 $ A $ 的一个 $ LU $ 分解。如果 $ n = 1 $，则构造完成，因为可以算则 $ L = I_1 $ (注：$ I_n $ 是单位阵)， $ U = A $。对于 $ n &gt; 1 $，我们把 $ A $ 拆成 4 部分 \\begin{bmatrix} a_{11} & | & a_{12} & \\cdots & a_{1n} \\\\ -&-&-&-&- \\\\ a_{21} & | & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & | \\\\ a_{n1} & | & a_{n2} & \\cdots & a_{nn} \\end{bmatrix} = \\begin{bmatrix} a_{11} & \\omega^T \\\\ \\upsilon & A' \\end{bmatrix}其中 $ \\upsilon $ 是一个 $ n - 1 $ 维列向量，$ \\omega^T $ 是一个 $ n - 1 $ 维行向量，$ A’ $ 是一个 $ (n - 1) \\times (n - 1) $ 矩阵。然后，利用矩阵代数 (通过简单地从头到尾使用乘法来验证方程式)，可以把 $ A $ 分解为 \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{11}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{11} & \\omega^T \\\\ 0 & A' - \\frac{\\upsilon\\omega^T}{a_{11}} \\end{bmatrix}项 $ \\frac{\\upsilon\\omega^T}{a_{11}} $ 是一个 $ (n - 1) \\times (n - 1) $ 矩阵，它与矩阵 $ A’ $ 大小一致。所得矩阵 A' - \\frac{\\upsilon\\omega^T}{a_{11}}称为矩阵 $ A $ 对于 $ a_{11} $ 的舒尔补。 如果矩阵 $ A $ 是非奇异的，那么舒尔补矩阵也是非奇异的。 因为舒尔补是非奇异的，现在我们可以递归地找出它的一个 $ LU $ 分解。我们说 A' - \\frac{\\upsilon\\omega^T}{a_{11}} = L'U'其中 $ L’ $ 是单位下三角矩阵，$ U’ $ 是上三角矩阵。然后，利用矩阵代数可得 \\begin{aligned} A &= \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{00}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{00} & \\omega^T \\\\ 0 & A' - \\frac{\\upsilon\\omega^T}{a_{00}} \\end{bmatrix} = \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{00}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k0} & \\omega^T \\\\ 0 & L'U' \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{00}} & L' \\end{bmatrix} \\begin{bmatrix} a_{00} & \\omega^T \\\\ 0 & U' \\end{bmatrix} = LU \\end{aligned} 时间复杂度 $ O(N^3) $ LUP分解算法实现示例(Example): \\begin{bmatrix} 2 & 0 & 2 & 0.6 \\\\ 3 & 3 & 4 & -2 \\\\ 5 & 5 & 4 & 2 \\\\ -1 & -2 & 3.4 & -1 \\end{bmatrix}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;const int N = 4;using namespace std;void lup(vector&lt;float&gt; &amp;P, float a[][N])&#123; for (size_t i = 0; i &lt; N; i++) &#123; float p = 0; size_t i_; for (size_t j = i; j &lt; N; j++) if (fabsf(a[j][i]) &gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (size_t j = 0; j &lt; N; j++) swap(a[i][j], a[i_][j]); for (size_t j = i + 1; j &lt; N; j++) &#123; a[j][i] /= a[i][i]; for (size_t k = i + 1; k &lt; N; k++) a[j][k] -= a[j][i] * a[i][k]; &#125; &#125;&#125;int main()&#123; vector&lt;float&gt; P(N); float b[][N] = &#123; 2, 0, 2, 0.6, 3, 3, 4, -2, 5, 5, 4, 2, -1, -2, 3.4, -1 &#125;; lup(P, b); cout &lt;&lt; \"B 矩阵:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) cout &lt;&lt; b[i][j] &lt;&lt; '\\t'; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"P 矩阵:\" &lt;&lt; endl; for (size_t i = 0; i &lt; P.size(); i++) cout &lt;&lt; i &lt;&lt; P[i] &lt;&lt; endl; return 0;&#125; version 2.lup() 1234567891011121314151617181920212223242526272829303132void lup2(vector&lt;vector&lt;float&gt;&gt;&amp;l, vector&lt;vector&lt;float&gt;&gt;&amp;u, vector&lt;float&gt; &amp;P, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; l[i][i] = 1; for (int j = i + 1; j &lt; N; j++) l[i][j] = 0; &#125; for (int i = 1; i &lt; N; i++) for (int j = 0; j &lt; i; j++) u[i][j] = 0; for (int i = 0; i &lt; N; i++) &#123; float p = 0; int i_; for (int j = i; j &lt; N; j++) if (fabsf(a[j][i]) &gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j &lt; N; j++) swap(a[i][j], a[i_][j]); u[i][i] = a[i][i]; for (int j = i + 1; j &lt; N; j++) &#123; l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; &#125; for (int j = i + 1; j &lt; N; j++) for (int k = i + 1; k &lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; &#125;&#125; LUP分解算法分析 原理：算法考虑每次计算过程，若主元为 $ 0 $ 或主元的值大于除数时，我们将找到合适的行与当前主元所在的行进行交换。比如，第 $ 1 $ 行，第 $ 1 $ 列为 $ 0 $，我们把第 $ 1 $ 行与第 $ k $ 行互换，这等价于用一个置换矩阵 $ Q $ 左乘矩阵 $ A $。因此可以把 $ QA $ 写成 QA = \\begin{bmatrix} a_{k1} & \\omega^T \\\\ \\upsilon & A' \\end{bmatrix}其中 \\begin{aligned} \\upsilon &= (a_{21}, a_{31}, \\cdots, a_{n1})^T \\\\ \\omega^T &= (a_{k2}, a_{k3}, \\cdots, a_{kn}) \\end{aligned}$ A’ $ 是一个 $ (n - 1) \\times (n - 1) $ 矩阵。因为 $ a_{k1} \\neq 0 $，现在可以执行与 $ LU $ 分解基本相同的线性代数运算，但现在能保证不会除以 0 QA = \\begin{bmatrix} a_{k1} & \\omega^T \\\\ \\upsilon & A' \\end{bmatrix} = \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{k1}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & A' - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix}如果 $ A $ 是非奇异的，那么舒尔补 $ A’ - \\frac{\\upsilon\\omega^T}{a_{k1}} $ 也是非奇异的。因此，可以递归地找出它的一个 $ LUP $ 分解，包括单位下三角矩阵 $ L’ $、上三角矩阵 $ U’ $ 和 置换矩阵 $ P’ $，满足 P'(A' - \\frac{\\upsilon\\omega^T}{a_{k1}}) = L'U'定义 P = \\begin{bmatrix} 1 & 0 \\\\ 0 & P' \\end{bmatrix} Q它是一个置换矩阵，因为它是两个置换矩阵的乘积。有 \\begin{aligned} PA &= \\begin{bmatrix} 1 & 0 \\\\ 0 & P' \\end{bmatrix} QA = \\begin{bmatrix} 1 & 0 \\\\ 0 & P' \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\\\ \\frac{\\upsilon}{a_{k1}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & A' - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 0 \\\\ P'\\frac{\\upsilon}{a_{k1}} & P' \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & A' - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix} = \\begin{bmatrix} 1 & 0 \\\\ P'\\frac{\\upsilon}{a_{k1}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & P'(A' - \\frac{\\upsilon\\omega^T}{a_{k1}}) \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 0 \\\\ P'\\frac{\\upsilon}{a_{k1}} & I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & L'U' \\end{bmatrix} = \\begin{bmatrix} 1 & 0 \\\\ P'\\frac{\\upsilon}{a_{k1}} & L' \\end{bmatrix} \\begin{bmatrix} a_{k1} & \\omega^T \\\\ 0 & U' \\end{bmatrix} = LU \\end{aligned}这样就推出了 $ LUP $ 分解。因为 $ L’ $ 是单位下三角矩阵，所以 $ L $ 也是单位下三角矩阵；又因为 $ U’ $ 是上三角矩阵，于是 $ U $ 也是上三角矩阵。 时间复杂度 $ O(N^3) $ 求解线性方程组算法有了以上基础知识以后，我们才能拿到 $ L $、$ U $、$ P $ ，步入最后一步求解出线性方程组 $ Ax = b $ 的向量解。 完整的算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;vector&gt;const int N = 3;using namespace std;void lu(vector&lt;vector&lt;float&gt;&gt; &amp;l, vector&lt;vector&lt;float&gt;&gt; &amp;u, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; l[i][i] = 1; for (int j = i + 1; j &lt; N; j++) l[i][j] = 0; &#125; for (int i = 1; i &lt; N; i++) for (int j = 0; j &lt; i; j++) u[i][j] = 0; for (int i = 0; i &lt; N; i++) &#123; u[i][i] = a[i][i]; for (int j = i + 1; j &lt; N; j++) &#123; l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; &#125; for (int j = i + 1; j &lt; N; j++) for (int k = i + 1; k &lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; &#125;&#125;void lup(vector&lt;float&gt; &amp;P, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; float p = 0; int i_; for (int j = i; j &lt; N; j++) if (fabsf(a[j][i]) &gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j &lt; N; j++) swap(a[i][j], a[i_][j]); for (int j = i + 1; j &lt; N; j++) &#123; a[j][i] /= a[i][i]; for (int k = i + 1; k &lt; N; k++) a[j][k] -= a[j][i] * a[i][k]; &#125; &#125;&#125;void lup2(vector&lt;vector&lt;float&gt;&gt;&amp;l, vector&lt;vector&lt;float&gt;&gt;&amp;u, vector&lt;float&gt; &amp;P, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; l[i][i] = 1; for (int j = i + 1; j &lt; N; j++) l[i][j] = 0; &#125; for (int i = 1; i &lt; N; i++) for (int j = 0; j &lt; i; j++) u[i][j] = 0; for (int i = 0; i &lt; N; i++) &#123; float p = 0; int i_; for (int j = i; j &lt; N; j++) if (fabsf(a[j][i]) &gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j &lt; N; j++) swap(a[i][j], a[i_][j]); u[i][i] = a[i][i]; for (int j = i + 1; j &lt; N; j++) &#123; l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; &#125; for (int j = i + 1; j &lt; N; j++) for (int k = i + 1; k &lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; &#125;&#125;void lup_solve(vector&lt;vector&lt;float&gt;&gt;&amp;l, vector&lt;vector&lt;float&gt;&gt;&amp;u, vector&lt;float&gt;&amp;x, vector&lt;float&gt;&amp;y, vector&lt;float&gt; b, float a[][N])&#123; for (int i = 0; i &lt; N; i++) &#123; float sum = 0; for (int j = 0; j &lt; i; j++) sum += l[i][j] * y[j]; y[i] = b[i] - sum; &#125; for (int i = N - 1; i &gt;= 0; i--) &#123; float sum = 0; for (int j = i + 1; j &lt; N; j++) sum += u[i][j] * x[j]; x[i] = (y[i] - sum) / u[i][i]; &#125;&#125;int main()&#123; vector&lt;vector&lt;float&gt;&gt; l(N, vector&lt;float&gt;(N)); vector&lt;vector&lt;float&gt;&gt; u(N, vector&lt;float&gt;(N)); /*float a[][N] = &#123; 2, 3, 1, 5, 6, 13, 5, 19, 2, 19, 10, 23, 4, 10, 11, 31 &#125;; float b[][N] = &#123; 2, 0, 2, 0.6, 3, 3, 4, -2, 5, 5, 4, 2, -1, -2, 3.4, -1 &#125;;*/ float c[][N] = &#123; 1, 2, 0, 3, 4, 4, 5, 6, 3 &#125;; vector&lt;float&gt; P(N); vector&lt;float&gt; x(N); vector&lt;float&gt; y(N); vector&lt;float&gt; b &#123; 3, 7, 8 &#125;; for (int i = 0; i &lt; N; i++) P[i] = (float)i; lup2(l, u, P, c); lup_solve(l, u, x, y, b, c); cout &lt;&lt; \"解向量 x:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) cout &lt;&lt; x[i] &lt;&lt; endl; return 0;&#125; 示例： \\begin{bmatrix} 1 & 2 & 0 \\\\ 3 & 4 & 4 \\\\ 5 & 6 & 3 \\end{bmatrix}output: 使用 lu() 函数 1234解向量 x:-1.42.20.6 使用 lup2() 函数 1234解向量 x:-10.087.941.92 算法分析显然，代码很直观的实现了对算法的描述过程，即利用正向替换，代换出 $ Ly = Pb $ 的 $ y $，然后再利用反向替换计算出 $ Ux = y $ 中的解向量 $ x $。 lup_solve()的时间复杂度为 $ O(N^2) $ 矩阵求逆$ A’ $ 是 $ A $ 的逆矩阵，则有 AA' = E其中 $ E $ 是单位阵。 设 $ X = A’ $， $ X_i $ 表示 $ X $ 的第 $ i $ 列， $ e_i $ 是 $ E $ 的第 $ i $ 列。于是可以利用 $ A $ 的 $ LUP $ 分解求解方程中的 $ X $，需分别求解每一个方程 AX_i = e_i中的 $ X_i $。一旦得到 $ LUP $ 分解，就可以在 $ O(N^2) $ 时间内计算 $ n $ 个 $ X_i $ 列中的每一个，因此可以在 $ O(N^3) $ 时间内从 $ A $ 的 $ LUP $ 分解计算 $ X $。既然可以在 $ O(N^3) $ 内确定出 $ A $ 的 $ LUP $ 分解，我们就可以在 $ O(N^3) $ 的时间内求矩阵 $ A $ 的逆矩阵 $ A’ $。 算法演示示例： \\begin{bmatrix} 1 & 2 & 0 \\\\ 3 & 4 & 4 \\\\ 5 & 6 & 3 \\end{bmatrix}12345678910111213141516171819202122232425262728int main()&#123; vector&lt;vector&lt;float&gt;&gt; l(N, vector&lt;float&gt;(N)); vector&lt;vector&lt;float&gt;&gt; u(N, vector&lt;float&gt;(N)); vector&lt;float&gt; x(N); vector&lt;float&gt; y(N); vector&lt;vector&lt;float&gt;&gt; E &#123; vector&lt;float&gt;&#123; 1, 0, 0 &#125;, vector&lt;float&gt;&#123; 0, 1, 0 &#125;, vector&lt;float&gt;&#123; 0, 0, 1&#125; &#125;; float a[][N] = &#123; 1, 2, 0, 3, 4, 4, 5, 6, 3 &#125;; lu(l, u, a); for (int j = 0; j &lt; E.size(); j++) &#123; lup_solve(l, u, x, y, E[j], a); cout &lt;&lt; \"解向量 X[\" &lt;&lt; j &lt;&lt; \"]:\" &lt;&lt; endl; for (int i = 0; i &lt; N; i++) cout &lt;&lt; x[i] &lt;&lt; endl; &#125; return 0;&#125; output: 123456789101112解向量 X[0]:-1.21.1-0.2解向量 X[1]:-0.60.30.4解向量 X[2]:0.8-0.4-0.2 即 A'= \\begin{bmatrix} -1.2 & -0.6 & 0.8 \\\\ 1.1 & 0.3 & -0.4 \\\\ -0.2 & 0.4 & -0.2 \\end{bmatrix}最后参考文献 [1] 《算法导论 第三版》 [2] 《线性代数 第五版》· 同济大学数学系 [3] matrix multiplicaton - wikipedia","path":"2018/09/08/matrix-operations/","date":"09-08","excerpt":""},{"title":"数学-导数篇（持续更新）","text":"简介这里主要存放一些导数题 题1.已知向量 $ a = (sin(x), \\frac{3}{4}), b = (cos(x), -1) $. (1) 当 $ a // b $ 时，求 $ cos^2(x) - sin(2x) $; (2) 设函数 $ f(x) = 2(\\vec{a} + \\vec{b}) \\cdot \\vec{b} $, 已知在△ABC中，内角A、B、C的对边分别为 $ a, b, c $,若 $ a = \\sqrt{3}, b = 2, sin(B) = \\frac{\\sqrt{6}}{3} $,求 $ f(x) + 4 cos(2A + \\frac{\\pi}{6})(x \\in [0, \\frac{\\pi}{3}]) $ 的取值范围。 题解： 这题虽然是一张向量试卷上的，但第二问基本上用导数就可以了，而且，我不知道题目给的几个边的条件有什么用… (1) 求 $ cos^2(x) - sin(2x) $ 由 $ a // b $，有： $ tan(x) = -\\frac{3}{4} $. 对 $ cos^2(x) - sin(2x) $ 做一些变形： \\begin{aligned} cos^2(x) - sin(2x) &= cos^2(x)(1 - \\frac{sin(2x)}{cos^2(x)}) \\\\ &= cos^2(x)(1 - \\frac{2sin(x)cos(x)}{cos^2(x)}) \\\\ &= cos^2(x)(1 - 2tan(x)) \\end{aligned}然后考虑 $ tan(x) = -\\frac{3}{4} = \\frac{sin(x)}{cos(x)} $ 有以下情况： $ \\sqrt{(-3)^2 + 4^2} = 5 $ 或 $ \\sqrt{3^2 + (-4)^2} = 5 $ $ sin(x) $ 为负或者 $ cos(x) $ 为负 既有 $ cos(x) = -\\frac{4}{5} $ 或者 $ cos(x) = \\frac{4}{5} $ 这并不影响到 $ cos^2(x) $ 的值，所以有： \\begin{aligned} cos^2(x) - sin(2x) &= cos^2(x)(1 - 2tan(x)) \\\\ &= \\frac{16}{25} \\cdot [1 - 2 \\cdot (-\\frac{3}{4})] \\\\ &= \\frac{8}{5} \\end{aligned}(2) 求 $ f(x) + 4cos(2A + \\frac{\\pi}{6}) (x \\in [0, \\frac{\\pi}{3}]) 的取值范围 $ 令 $ \\varphi (x) = f(x) + 4cos(2A + \\frac{\\pi}{6}) (x \\in [0, \\frac{\\pi}{3}]) $ 由题目条件知： $ f(x) = 2cos^2(x) + sin(2x) + \\frac{1}{2} $ \\begin{aligned} f'(x) &= -4cos(x)sin(x) + 2cos(2x) \\\\ &= 2(cos(2x) - sin(2x)) \\\\ &= 2\\sqrt{2}sin(\\frac{\\pi}{4} - 2x) \\end{aligned}令 $ f’(x) = 0 $, 则可得到 $ x = \\frac{\\pi}{8} + 2k\\pi (k = 0,1,2…) $ $ \\because x \\in [0, \\frac{\\pi}{3}], \\therefore x = \\frac{\\pi}{8} $ 又 ① $ f’(0) &gt; 0; $② $ f’(\\frac{\\pi}{3}) &lt; 0. $ 考虑到 $ f’(x) $ 是一个最小周期为 $ \\pi $ 的函数，所以 $ f’(x) $ 在 $ x \\in [0, \\frac{\\pi}{3}] $ 内要么单调递增，要么单调递减，所以有如下分析： ① $ f’(x) $ 在 $ x \\in [0, \\frac{\\pi}{3}) $ 恒大于 0，则原函数 $ f(x) $ 在 $ x \\in [0, \\frac{\\pi}{3}) $ 内单调递增;② $ f’(x) $ 在 $ x \\in (\\frac{\\pi}{8}, \\frac{\\pi}{3}] $ 恒小于 0，则原函数 $ f(x) $ 在 $ x \\in (\\frac{\\pi}{8}, \\frac{\\pi}{3}] $ 内单调递减. 所以 $ x = \\frac{\\pi}{8} $ 为 $ f(x) $ 在 $ x \\in [0, \\frac{\\pi}{3}) $ 内的唯一一个最大值. 又 $ f(0) &gt; f(\\frac{\\pi}{3}) $ ，所以，$ f(\\frac{\\pi}{3}) $ 是 $ f(x) $ 在 $ x \\in [0, \\frac{\\pi}{3}) $ 内的唯一一个最小值. 可以借助工具来画出函数图看一看是否正确： $ f(\\frac{\\pi}{8}) = \\frac{3}{2} + \\sqrt{2}, f(\\frac{\\pi}{3}) = 1 + \\frac{\\sqrt{3}}{2} $ 于是 \\begin{aligned} max \\ \\varphi(x) &= f(\\frac{\\pi}{8}) + 4 = \\frac{11}{2} + \\sqrt{2} \\\\ min \\ \\varphi(x) &= f(\\frac{\\pi}{3}) - 4 = \\frac{\\sqrt{3}}{2} - 3 \\end{aligned}2.","path":"2018/09/05/math-derivative/","date":"09-05","excerpt":""},{"title":"高等数学-积分方程篇（持续更新）","text":"前言这里存放一些积分方程题的题解。 题1.求 $ \\int_{0}^{\\frac{\\pi}{4}} x \\ \\prod cos(\\frac{x}{2^k}) dx $ (from MIT 2015 Integration Bee) (这个题是在youtube上看到的，解法也是看了大神的，然后就记住了) 题解： 注意到 $ \\prod cos(\\frac{x}{2^k}) = cos(\\frac{x}{2}) \\cdot cos(\\frac{x}{2^2}) \\cdot \\cdot \\cdot $ 利用 $ sin(2x) = 2sin(x)cos(x) \\Rightarrow cos(x) = \\frac{sin(2x)}{2sin(x)} $ 将上面第一个等式最右边按照上式规则写出来，有： $ cos(\\frac{x}{2}) \\cdot cos(\\frac{x}{2^2}) \\cdot cos(\\frac{x}{2^2}) \\cdots = \\frac{sin(x)}{2sin(\\frac{x}{2})} \\cdot \\frac{sin(\\frac{x}{2})}{2sin(\\frac{x}{2^2})} \\cdot \\frac{sin(\\frac{x}{2^2})}{2sin(\\frac{x}{2^3})} \\cdots $ 观察等式右边发现，除第一项分子以外，后一项的分子总是能和前一项的分母约掉，于是我们可以得到这样的形式： $ \\frac{sin(x)}{2^k sin(\\frac{x}{2^k})}, k \\rightarrow \\infty $ 于是，我们来愉快的求极限： \\begin{aligned} \\lim_{k \\rightarrow \\infty} \\frac{sin(x)}{2^k sin(\\frac{x}{2^k})} &= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{2^k sin(\\frac{x}{2^k})} \\\\ &= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{x\\frac{sin(\\frac{x}{2^k})}{\\frac{x}{2^k}}} \\\\ &= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{x \\cdot 1} \\\\ &= \\frac{sin(x)}{x} \\end{aligned}所以，积分方程中的那一坨 $ \\prod cos(\\frac{x}{2^k}) = \\frac{sin(x)}{x} $ 带入积分方程并计算： \\begin{aligned} \\int_{0}^{\\frac{\\pi}{4}} x \\ \\prod cos(\\frac{x}{2^k}) dx &= \\int_{0}^{\\frac{\\pi}{4}} x \\ \\frac{sin(x)}{x} dx \\\\ &= \\int_{0}^{\\frac{\\pi}{4}} sin(x) dx \\\\ &= -cos(x)|_{0}^{\\frac{\\pi}{4}} \\\\ &= -cos(\\frac{\\pi}{4}) - (-cos(0)) \\\\ &= 1 - \\frac{\\sqrt{2}}{2} \\end{aligned}2.求 $ \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx $ 的值(这个题也前面说的哪个大神做的) 题解： \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx = \\int_{0}^{\\infty} x \\ e^{1-x} dx + \\int_{0}^{\\infty} \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx等式右边第一项积分很好算： \\begin{aligned} \\int_{0}^{\\infty} x \\ e^{1-x} dx &= e\\int_{0}^{\\infty} x \\ e^{-x} \\\\ &= e(-x \\ e^{-x}|_{0}^{\\infty} - e^{-x}|_{0}^{\\infty}) \\\\ &= e[-e^{-x}(1+x)|_{0}^{\\infty}] \\\\ &= e \\end{aligned}现在来计算一下等式右边第二项积分： 令 $ S = \\int_{0}^{\\infty} \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx $ 我们来看一下 $ f(x) = \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} $ 的函数图： 然后写几项看看，我们会发现可以用简单的级数形式来表示： \\begin{aligned} S &= 0 \\cdot 1 + 1 \\cdot 1 + 2 \\cdot \\frac{1}{e} + 3 \\cdot \\frac{1}{e^2} + \\cdots \\\\ &= 1 + \\frac{2}{e} + \\frac{3}{e^2} + \\cdots \\\\ &= \\sum_{x=0}^{\\infty} \\frac{x}{e^{x-1}} \\end{aligned}现在来求这个级数的和： \\begin{aligned} S &= 1 + \\frac{2}{e} + \\frac{3}{e^2} + \\cdots \\quad (1) \\\\ \\frac{1}{e} \\cdot S &= \\frac{1}{e} + \\frac{2}{e^2} + \\frac{3}{e^3} + \\cdots \\quad (2) \\end{aligned}利用 (1)式 - (2)式 有： \\begin{aligned} S - \\frac{1}{e} \\cdot S &= 1 + \\frac{1}{e} + \\frac{1}{e^2} + \\frac{1}{e^3} + \\cdots \\\\ &= \\sum_{n=0}^{\\infty} (\\frac{1}{e})^n \\\\ (1-\\frac{1}{e})S &= \\frac{1}{1-\\frac{1}{e}} \\\\ \\Rightarrow S &= \\frac{1}{(1-\\frac{1}{e})^2} \\end{aligned}回到原题 $ \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx = e + \\frac{1}{(1-\\frac{1}{e})^2} $ 3.","path":"2018/09/03/integral-equation/","date":"09-03","excerpt":""},{"title":"高中数学-向量篇（持续更新）","text":"简介这里是关于向量运算的题目题解，题目质量大概参差不齐。 向量在现代数学和物理中有着很重要的作用，指的是一种具有大小和方向的量。又叫做矢量(vector)。 Vector - wikipedia 题1.已知向量 $ \\vec{OA}, \\vec{OB} $ 满足 $ |OA| = |OB| = 1, \\vec{OA} \\cdot \\vec{OB} = 0, \\vec{OC} = \\lambda \\ \\vec{OA} + \\mu \\ \\vec{OB} (\\lambda ,\\mu \\in \\mathbb{R}) $. 若 $ M $ 为 $ AB $ 的中点，并且 $ |\\vec{MC}| = 1 $, 则点 $ (\\lambda , \\mu) $ 在 ( B ) A.以 $ (-\\frac{1}{2}, \\frac{1}{2}) $ 为圆心，半径为1的圆上.B.以 $ (\\frac{1}{2}, -\\frac{1}{2}) $ 为圆心，半径为1的圆上.C.以 $ (-\\frac{1}{2}, -\\frac{1}{2}) $ 为圆心，半径为1的圆上.D.以 $ (\\frac{1}{2}, \\frac{1}{2}) $ 为圆心，半径为1的圆上. 题解： 假设 $ A $ 点的坐标为 $ (x_0, y_0) $, $ B $ 点的坐标为 $ (x_1, y_1) $. 由题目前2个条件知： $ x_0 ^2 + y_0 ^2 = 1, x_1 ^2 + y_1 ^2 = 1, x_0 \\ x_1 + y_0 \\ y_1 = 0 $ 将 $ A,B $ 点坐标带入第3个条件：$ \\vec{OC} = \\lambda \\ \\vec{OA} + \\mu \\ \\vec{OB} (\\lambda ,\\mu \\in \\mathbb{R}) $ 于是求出 $ C $ 的坐标：$ (\\lambda \\ x_0 + \\mu \\ x_1, \\lambda \\ y_0 + \\mu \\ y_1) $ $ M $ 是 $ AB $ 的中点，所以得到 $ M $ 的坐标为：$ (\\frac{x_1 - x_0}{2}, \\frac{y_1 - y_0}{2}) $ 又因为 $ |\\vec{MC}| = 1 $, 把上面 $ M, C $ 的坐标代入进行计算并化简，最终可得： $ (\\lambda + \\frac{1}{2})^2 + (\\mu - \\frac{1}{2})^2 = 1 $ 所以，选 B. 2.","path":"2018/09/02/math-vector/","date":"09-02","excerpt":""},{"title":"Kruskal's algorithm","text":"算法简介Kruskal算法可用来求解最小生成树(minimum-spanning-tree, MST)问题，还可以用来生成迷宫。 算法分析其实算法不难理解，算法先要将 $ G(V, E) $ 的集合 $ E $ 按权重 $ \\Omega $ 由小到大排序，然后还利用了不相交集中的find()(这里使用的是带路径压缩功能的) 和union()(这里函数名使用marge()) 函数，find()用于判断是否连通，如果连通则不能构成MST，反之则加入到MST的集合中，并调用union()函数将顶点连通。 时间复杂度分析$ O(E lg V) $ 空间复杂度分析$ O(V + E) $ 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int N = 10010;int p[N];vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; graph;void init(int V, int E)&#123; for (int i = 1; i &lt;= V; i++) p[i] = i; for (int i = 0; i &lt; E; i++) &#123; int w, s, e; cin &gt;&gt; w &gt;&gt; s &gt;&gt; e; graph.push_back(pair&lt;int, pair&lt;int ,int&gt;&gt;(w, pair&lt;int, int&gt;(s, e))); &#125; sort(graph.begin(), graph.end()); for (auto e : graph) cout &lt;&lt; e.first &lt;&lt; e.second.first &lt;&lt; e.second.second &lt;&lt; endl;&#125;int find(int x)&#123; if (x != p[x]) p[x] = find(p[x]); return p[x];&#125;void marge(int x, int y)&#123; int r = find(x), t = find(y); if (r != t) p[r] = t;&#125;vector&lt;pair&lt;int, int&gt;&gt; kruskal(int V, int E)&#123; vector&lt;pair&lt;int, int&gt;&gt; msts; init(V, E); for (vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;::iterator i = graph.begin(); i != graph.end(); i++) &#123; if (find(i-&gt;second.first) != find(i-&gt;second.second)) &#123; msts.push_back(i-&gt;second); marge(i-&gt;second.first, i-&gt;second.second); &#125; &#125; return msts;&#125;int main(int argc, char **argv)&#123; int V, E; cin &gt;&gt; V &gt;&gt; E; vector&lt;pair&lt;int, int&gt;&gt; es = kruskal(V, E); for (auto e : es) cout &lt;&lt; e.first &lt;&lt; \" \" &lt;&lt; e.second &lt;&lt; endl; return 0;&#125; 参考1.Kruskal’s algorithm - wikipedia2.Maze generation algorithm - wikipedia3.CLRS $ P_{366} $ 伪代码","path":"2018/08/29/kruskal-s-algorithm/","date":"08-29","excerpt":""},{"title":"Tarjan's algorithm","text":"算法简介Tarjan算法可以用来求有向图的强连通分量个数。算法由Robert Tarjan于1972年发明的。 算法分析Tarjan算法的主要算法部分也是dfs（深度优先搜索），但利用了重要的额外信息。下面详细分析一下算法执行过程。 再强调一下强连通子图的重要特点：对于强连通子图，有一个特定的事实就是，该子图一定形成环，那么从该子图中任意点出发，总能回到出发点。 基于上面这一点，Tarjan算法通过维护两个存放顶点访问顺序（时间）的数组。如果子图形成环，则将处于环中的每一个顶点的访问顺序置为该环的出发点的访问时间，以表明他们是一个强连通子图。可能你会怀疑进入环后，不会只在环中遍历，可能会跳到其他顶点上。实际上这担心是多余，因为图结构使用邻接链表表示，强连通子图使用dfs进行遍历时，只会寻找与当前顶点连接的出度顶点，而形成环的子图中，会很合理的按顺序遍历完。对于孤立点，则自身就是一个环，即强连通分量。 这就是Tarjan算法的思想，主要的就是 维护两个存储访问顺序的数组，然后，将形成环的节点的访问时间都置为该强连通子图的出发点的访问时间。 通过下图可以更直观的理解Tarjan算法的执行过程（图来自维基）： 时间复杂度分析最坏情况是图G的强连通子图就是其本身（这样的图称为强连通图），这时dfs的消费为 $ O(|V| + |E|) $，最后一次dfs的while循环再消费掉 $ O(V) $，所以dfs()最坏情况为 $ O(|V| + |E|) $。最后tarjan()的总消耗为 $ O (V^2) $。 空间复杂度分析显然为 $ O(V) $。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;list&gt;#include &lt;minmax.h&gt;using namespace std;const int N = 10010;list&lt;int&gt; *adj;stack&lt;int&gt; s;int vis[N], low[N];bool onstack[N];int times = 0, scc = 0;void addEdge(int u, int v)&#123; adj[u].push_back(v);&#125;void dfs(int u)&#123; vis[u] = low[u] = times++; s.push(u); onstack[u] = true; for (list&lt;int&gt;::iterator i = adj[u].begin(); i != adj[u].end(); ++i) &#123; int v = *i; if (vis[v] == -1) &#123; dfs(v); low[u] = min(low[u], low[v]); &#125; else if (onstack[v] == true) low[u] = min(low[u], vis[v]); &#125; if (low[u] == vis[u]) &#123; while (s.top() != u) &#123; int w = s.top(); cout &lt;&lt; w &lt;&lt; ' '; onstack[w] = false; s.pop(); &#125; int w = s.top(); cout &lt;&lt; w &lt;&lt; endl; onstack[w] = false; s.pop(); scc++; &#125;&#125;void tarjan(int V, int E)&#123; adj = new list&lt;int&gt;[V + 1]; list&lt;int&gt; v; for (int i = 1; i &lt;= V; i++) &#123; vis[i] = low[i] = -1; onstack[i] = false; &#125; for (int i = 1; i &lt;= E; i++) &#123; int u, w; cin &gt;&gt; u &gt;&gt; w; adj[u].push_back(w); &#125; for (int i = 1; i &lt;= V; i++) if (vis[i] == -1) dfs(i); cout &lt;&lt; \"该图的强连通分量个数为：\" &lt;&lt; scc &lt;&lt; endl;&#125;int main(int argc, char **argv)&#123; int V, E; cin &gt;&gt; V &gt;&gt; E; tarjan(V, E); return 0;&#125; 代码中dfs()函数的for循环后面的部分用来输出所有强连通子图中的顶点，并求出scc（Strongly Connected Components）个数。 下面以前面wiki图为例测试一下算法。 算法测试结果： 123453 2 17 65 48该图的强连通分量个数为：4 参考1.Strongly connected components algorithm - wikipedia2.Strongly connected components algorithm","path":"2018/08/27/tarjan-s-algorithm/","date":"08-27","excerpt":""},{"title":"贪吃蛇","text":"前言贪吃蛇是我小时候很喜欢玩的一个小游戏，最近比较闲，忽然想起曾经在网上看过一段很不错的贪吃蛇的源码，当时很想能自己写一个，随着时间推移，却越来越不想做这类小游戏了。不过，前几天提起了一点兴趣，做了一下，发现还是很有趣，也很有意义的。 关于游戏历史Snake - wikipedia 设计花絮我一开始做的时候，没有注意到一个重要的事实，那就是对于蛇头方向的选择，后来发现，确定一个节点为蛇头，然后只控制蛇头会使得事情简单很多。下面具体说一说，一开始使用的数据结构是头插法创建的单链表，但对于蛇头在哪边以及该怎么移动，却没考虑清楚（想到这里就扶额 = =），比如，一开始的蛇是这样的: 12345o --- 蛇头oooo --- 蛇尾 但我设定的最开始的移动却是向下移动的。。。准确的说我对蛇头的选择是随时在改变的，我考虑如果往上就用头节点，如果往下就用尾节点，但其实根本没必要，而且这样会更麻烦，甚至在蛇会变长的情况下效率是有问题的（后来才发现自己多蠢）。 如果是在指定蛇头的方向移动，实际上最有效率的做法是申请一个新节点，并把位置设置在节点头节点的前面，然后节点接在头节点前，并将尾节点的位置设置为尾节点前一个，最后移除尾节点即可。数据结构使用双向链表的话，时间复杂度 $ O(1) $。 总之呢，不管数据结构是单链表还是双向链表还是队列，指定蛇头在哪个方向，就往哪个方向移动就好了，不管是指定头节点为蛇头还是尾节点为蛇头，总之指定其中一个为蛇头即可。 源代码 note: 仅支持windows下的Visual Studio自带的编译器和g++编译器 代码更新日志（历史按最新代码时间排序）2018-08-29 am.7点左右使用 STL deque 代替双向链表重新实现了一下。并把 x、y 的值范围分别改为 1~70、1~30。也把判断穿墙的 == 改为了 &lt;= 或者 &gt;= ，这样可以修复掉当 x 为奇数时出现的 bug。 由于实际效果与之前的差不多就不再贴游戏截图了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;deque&gt;#include &lt;set&gt;#include &lt;time.h&gt;typedef enum &#123; U, D, L, R &#125; Status;Status status = U;void SetPosition(short x, short y)&#123; HANDLE winHandle; COORD pos = &#123; x, y &#125;; winHandle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(winHandle, pos);&#125;bool IsCollised(std::deque&lt;std::pair&lt;int, int&gt;&gt; h, std::pair&lt;int, int&gt; f)&#123; return h.front().first == f.first &amp;&amp; h.front().second == f.second;&#125;bool IsCollisSelf(std::deque&lt;std::pair&lt;int, int&gt;&gt; h)&#123; std::deque&lt;std::pair&lt;int, int&gt;&gt; self = h; self.pop_front(); while (!self.empty()) &#123; if (IsCollised(h, self.front())) return true; self.pop_front(); &#125; return false;&#125;void GenerateFood(std::deque&lt;std::pair&lt;int, int&gt;&gt; h, std::pair&lt;int, int&gt; &amp; f)&#123; srand((unsigned int)time(0)); int x = rand() % 68 + 1; int y = rand() % 28 + 1; f.first = x &amp; 1 ? x + 1 : x; f.second = y; for (std::deque&lt;std::pair&lt;int, int&gt;&gt;::iterator self = h.begin(); self != h.end(); ++self) if (self-&gt;first == f.first &amp;&amp; self-&gt;second == f.second) GenerateFood(h, f); SetPosition(f.first, f.second); std::cout &lt;&lt; \"■\";&#125;void Init(std::deque&lt;std::pair&lt;int, int&gt;&gt; &amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; for (int i = 0; i &lt;= 4; i++) &#123; SetPosition(24, 8 + i); std::cout &lt;&lt; \"■\"; h.push_back(std::pair&lt;int, int&gt;(24, 8 + i)); &#125; GenerateFood(h, f);&#125;void MoveUp(std::deque&lt;std::pair&lt;int, int&gt;&gt;&amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; h.push_front(std::pair &lt;int, int&gt;(h.front().first, h.front().second - 1)); if (h.front().second &lt;= 0) h.front().second = 30; SetPosition(h.front().first, h.front().second); std::cout &lt;&lt; \"■\"; if (!IsCollised(h, f)) &#123; SetPosition(h.back().first, h.back().second); h.pop_back(); std::cout &lt;&lt; \" \"; &#125; else GenerateFood(h, f);&#125;void MoveDown(std::deque&lt;std::pair&lt;int, int&gt;&gt;&amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; h.push_front(std::pair &lt;int, int&gt;(h.front().first, h.front().second + 1)); if (h.front().second &gt;= 30) h.front().second = 0; SetPosition(h.front().first, h.front().second); std::cout &lt;&lt; \"■\"; if (!IsCollised(h, f)) &#123; SetPosition(h.back().first, h.back().second); h.pop_back(); std::cout &lt;&lt; \" \"; &#125; else GenerateFood(h, f);&#125;void MoveLeft(std::deque&lt;std::pair&lt;int, int&gt;&gt;&amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; h.push_front(std::pair &lt;int, int&gt;(h.front().first - 2, h.front().second)); if (h.front().first &lt;= 0) h.front().first = 70; SetPosition(h.front().first, h.front().second); std::cout &lt;&lt; \"■\"; if (!IsCollised(h, f)) &#123; SetPosition(h.back().first, h.back().second); h.pop_back(); std::cout &lt;&lt; \" \"; &#125; else GenerateFood(h, f);&#125;void MoveRight(std::deque&lt;std::pair&lt;int, int&gt;&gt;&amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; h.push_front(std::pair &lt;int, int&gt;(h.front().first + 2, h.front().second)); if (h.front().first &gt;= 70) h.front().first = 0; SetPosition(h.front().first, h.front().second); std::cout &lt;&lt; \"■\"; if (!IsCollised(h, f)) &#123; SetPosition(h.back().first, h.back().second); h.pop_back(); std::cout &lt;&lt; \" \"; &#125; else GenerateFood(h, f);&#125;void Game(std::deque&lt;std::pair&lt;int, int&gt;&gt; &amp;h, std::pair&lt;int, int&gt; &amp;f)&#123; while (1) &#123; Sleep(200); if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) status = U; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) status = D; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) status = L; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) status = R; else if (status == U) MoveUp(h, f); else if (status == D) MoveDown(h, f); else if (status == L) MoveLeft(h, f); else if (status == R) MoveRight(h, f); if (IsCollisSelf(h)) return; &#125;&#125;int main(int argc, char **argv)&#123; std::deque&lt;std::pair&lt;int, int&gt;&gt; snake; std::pair&lt;int, int&gt; food; Init(snake, food); Game(snake, food); return 0;&#125; 2018-08-26 pm.6点左右目前游戏效果： 2018-08-28 pm.6点左右 修改了一下代码，将判断穿越四周的‘==’ 改为 ‘&gt;=’ 或 ‘&lt;=’。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;time.h&gt;typedef enum &#123; U, D, L, R &#125; Status;typedef struct Snake&#123; char body[3]; int x, y; Snake*pre_node, *next_node; Snake() : body(\"■\"), pre_node(nullptr), next_node(nullptr) &#123;&#125; Snake(int x1, int y1) : body(\"■\"), x(x1), y(y1), pre_node(nullptr), next_node(nullptr) &#123; &#125;&#125; SnakeBody;SnakeBody*head = nullptr;SnakeBody*tail = nullptr;SnakeBody*food = nullptr;Status status = U;void SetPosition(short x, short y)&#123; HANDLE winHandle; COORD pos = &#123; x, y &#125;; winHandle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(winHandle, pos);&#125;bool IsCollised(SnakeBody*h, SnakeBody*f)&#123; if (!f) return false; return h-&gt;x == f-&gt;x &amp;&amp; h-&gt;y == f-&gt;y;&#125;bool IsCollisSelf(SnakeBody*h, SnakeBody*t)&#123; SnakeBody*self = t; while (self-&gt;pre_node != h) &#123; if (IsCollised(h, self)) return true; self = self-&gt;pre_node; &#125; return false;&#125;void GenerateFood(SnakeBody*t)&#123; srand((unsigned int)time(0)); int x = rand() % 67 + 1; int y = rand() % 26 + 1; food = new Snake(x &amp; 1 ? x + 1 : x, y); SnakeBody*self = t; while (self) &#123; if (IsCollised(self, food)) &#123; delete food; food = nullptr; GenerateFood(t); &#125; self = self-&gt;pre_node; &#125; SetPosition(food-&gt;x, food-&gt;y); printf(\"%s\", food-&gt;body);&#125;void Init()&#123; head = new Snake(24, 8); SnakeBody*s_body = head; for (int i = 1; i &lt;= 4; i++) &#123; SnakeBody* cur_n = new Snake(head-&gt;x, head-&gt;y + i); cur_n-&gt;pre_node = s_body; s_body-&gt;next_node = cur_n; s_body = cur_n; &#125; tail = s_body; s_body = head; while (s_body) &#123; SetPosition(s_body-&gt;x, s_body-&gt;y); printf(\"%s\", s_body-&gt;body); s_body = s_body-&gt;next_node; &#125;&#125;void MoveUp(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x, h-&gt;y - 1); if (n-&gt;y == 0) n-&gt;y = 28; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; if (!IsCollised(h, food)) &#123; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); t = t-&gt;pre_node; delete t-&gt;next_node; &#125; else &#123; delete food; food = nullptr; GenerateFood(tail); &#125;&#125;void MoveDown(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x, h-&gt;y + 1); if (n-&gt;y == 28) n-&gt;y = 0; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; if (!IsCollised(h, food)) &#123; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); t = t-&gt;pre_node; delete t-&gt;next_node; &#125; else &#123; delete food; food = nullptr; GenerateFood(tail); &#125;&#125;void MoveLeft(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x - 2, h-&gt;y); if (n-&gt;x == 0) n-&gt;x = 68; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; if (!IsCollised(h, food)) &#123; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); t = t-&gt;pre_node; delete t-&gt;next_node; &#125; else &#123; delete food; food = nullptr; GenerateFood(tail); &#125;&#125;void MoveRight(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x + 2, h-&gt;y); if (n-&gt;x == 68) n-&gt;x = 0; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; if (!IsCollised(h, food)) &#123; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); t = t-&gt;pre_node; delete t-&gt;next_node; &#125; else &#123; delete food; food = nullptr; GenerateFood(tail); &#125;&#125;void Game()&#123; GenerateFood(tail); while (1) &#123; Sleep(200); if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) status = U; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) status = D; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) status = L; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) status = R; else if (status == U) MoveUp(head, tail); else if (status == D) MoveDown(head, tail); else if (status == L) MoveLeft(head, tail); else if (status == R) MoveRight(head, tail); if (IsCollisSelf(head, tail)) return; &#125;&#125;void DeleteSnake(SnakeBody*&amp;h)&#123; if (h) &#123; DeleteSnake(h-&gt;next_node); delete h; h = nullptr; &#125;&#125;int main(int argc, char **argv)&#123; Init(); Game(); DeleteSnake(head); return 0;&#125; 2018-08-24 pm.8点左右解决了前面提到的bug。 效果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;#include &lt;windows.h&gt;typedef enum &#123; U, D, L, R &#125; Status;typedef struct Snake&#123; char body[3]; int x, y; Snake*pre_node, *next_node; Snake() : body(\"■\"), pre_node(nullptr), next_node(nullptr) &#123;&#125; Snake(int x1, int y1) : body(\"■\"), x(x1), y(y1), pre_node(nullptr), next_node(nullptr) &#123; &#125;&#125; SnakeBody;SnakeBody*head = nullptr;SnakeBody*tail = nullptr;Status status = U;void SetPosition(short x, short y)&#123; HANDLE winHandle; COORD pos = &#123;x, y&#125;; winHandle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(winHandle, pos); &#125;void Init()&#123; head = new Snake(24, 8); SnakeBody*s_body = head; for (int i = 1; i &lt;= 4; i++) &#123; SnakeBody* cur_n = new Snake(head-&gt;x, head-&gt;y + i); cur_n-&gt;pre_node = s_body; s_body-&gt;next_node = cur_n; s_body = cur_n; &#125; tail = s_body; s_body = head; while (s_body) &#123; SetPosition(s_body-&gt;x, s_body-&gt;y); printf(\"%s\", s_body-&gt;body); s_body = s_body-&gt;next_node; &#125;&#125;void MoveUp(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x, h-&gt;y - 1); if (n-&gt;y == 0) n-&gt;y = 28; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); t = t-&gt;pre_node; delete t-&gt;next_node;&#125;void MoveDown(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x, h-&gt;y + 1); if (n-&gt;y == 28) n-&gt;y = 0; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); n = t; t = t-&gt;pre_node; delete n;&#125;void MoveLeft(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x - 2, h-&gt;y); if (n-&gt;x == 0) n-&gt;x = 68; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); n = t; t = t-&gt;pre_node; delete n;&#125;void MoveRight(SnakeBody*&amp;h, SnakeBody*&amp;t)&#123; SnakeBody*n = new Snake(h-&gt;x + 2, h-&gt;y); if (n-&gt;x == 68) n-&gt;x = 0; SetPosition(n-&gt;x, n-&gt;y); printf(\"%s\", n-&gt;body); n-&gt;next_node = h; h-&gt;pre_node = n; h = n; SetPosition(t-&gt;x, t-&gt;y); printf(\" \"); n = t; t = t-&gt;pre_node; delete n;&#125;void Game()&#123; while(1) &#123; Sleep(200); if (GetAsyncKeyState(VK_UP) &amp;&amp; status != D) status = U; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; status != U) status = D; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; status != R) status = L; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; status != L) status = R; else if (status == U) MoveUp(head, tail); else if (status == D) MoveDown(head, tail); else if (status == L) MoveLeft(head, tail); else if (status == R) MoveRight(head, tail); &#125;&#125;void DeleteSnake(SnakeBody*h)&#123; if (h) &#123; DeleteSnake(h-&gt;next_node); delete h; &#125;&#125;int main(int argc, char **argv)&#123; Init(); Game(); DeleteSnake(head); return 0;&#125; 2018-08-24 pm.7点半左右目前代码有个迷のbug。。。 如下图所示：","path":"2018/08/24/esurient-snake/","date":"08-24","excerpt":""},{"title":"拓扑排序","text":"拓扑排序简介生活中许多实际应用都需要使用有向无环图来指明事件的优先次序。比如我们早上起床穿衣洗漱的次序等。借用《CLRS》中举的例子，我制作了一张相同的图来描述这个概念： 上图描述了，一个教授每天早上起床穿衣所发生的事件的次序图。教授必须先穿上某些衣物，才能再穿其他衣服（比如先穿上袜子才能再穿鞋子）。有些服饰则无先后次序，可以按任意顺序穿上。 如果我们按照教授每件衣物穿好时的时间排序，然后得到逆序，我们就可以看到教授的穿戴顺序，这样一个顺序就是拓扑排序。所以，拓扑排序的概念很简单。 但需要注意的是这样的事情必须发生在有向无环图中，假如有环，我们可以想象，教授这一些列动作是不可能完成的。。。 算法思路如上面所说，我们的目的就是记录每个物件穿戴完成的时间，也就是在一个有向无环图中记录遍历过的每一个顶点v的离开时间，这只需要额外的一个 $ O(V) $ 空间消耗。 算法实现123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define INF 0x3f3fint visied[INF], graph[INF][INF];int d[INF], f[INF]; // 访问前的时间，访问后的时间，记录整个任务过程的时间线int V, t = 0; // t表示时间void dfs(int v)&#123; t += 1; d[v] = t; visied[v] = 1; for (int i = 1; i &lt;= V; i++) if (!visied[i] &amp;&amp; graph[v][i]) dfs(i); t += 1; f[v] = t;&#125;void topological_sort()&#123; // sort to array f&#125;int main()&#123; int E, s, e; scanf(\"%d %d\", &amp;V, &amp;E); memset(visied, 0, sizeof(visied)); memset(d, 0, sizeof(d)); memset(f, 0, sizeof(f)); for (int i = 0; i &lt; E; i++) &#123; scanf(\"%d %d\", &amp;s, &amp;e); graph[s][e] = 1; &#125; for (int i = 1; i &lt;= V; i++) if (!visied[i]) dfs(i); for (int i = 1; i &lt;= V; i++) printf(\"%d: %d\\n\", i, f[i]); return 0;&#125; 测试用例如图： output: 123456781: 102: 123: 94: 45: 86: 167: 158: 7 按时间逆序排序，看看顶点访问顺序： 16 7 2 1 3 8 5 4 结合前面的拓扑排序概念，可以证明这个排序是合理的。 时间复杂度分析这是用邻接矩阵表示法实现的，所以排序时间复杂度为 $ O(V lg V) $，如果节点并不多可以使用一些空间换时间的排序手段降低排序时间。 参考1.CRLS","path":"2018/08/24/topological-sort/","date":"08-24","excerpt":""},{"title":"抛物线（待更新）","text":"如何画抛物线该篇中您将看到： 在控制台画简单的抛物线 在窗口画布中画出复杂的抛物线 算法实现抛物线公式画抛物线这里用的抛物线公式：$ y = px^2 $ 1234567891011121314151617181920212223#include &lt;stdio.h&gt;double square(double x)&#123; return x*x;&#125;void parabola(double x, double a, double b)&#123; double y; for (double i = 0.; i &lt; x; i += 0.5) &#123; y = square(i); for (double j = 0.; j &lt; y/a; j += 1.) puts(\"\"); for (double j = 0.; j &lt; b*i; j += 1.) printf(\" \"); puts(\"*\"); &#125;&#125;int main()&#123; parabola(6., 2., 10.); return 0;&#125; 利用平抛运动轨迹画抛物线平抛运动坐标计算公式：$ x = v_0 t, y = \\frac{g t^2}{2} $ 123456789101112131415161718192021222324#include &lt;stdio.h&gt;double square(double x)&#123; return x*x;&#125;// 适当调整λ系数，让曲线变密集，系数分母越大曲线趋向于直线void Horizontal_projectile_motion_track(double t, double g, double v, double lambda)&#123; double x, y; for (double i = 0.; i &lt; t; i += 1.) &#123; x = v*i, y = g*square(i)/(2.*lambda); for (double j = 0.; j &lt; y; j += 1.) puts(\"\"); for (double j = 0.; j &lt; x; j += 1.) printf(\" \"); puts(\"*\"); &#125;&#125;int main()&#123; Horizontal_projectile_motion_track(15., 9.8, 6., 1000.); return 0;&#125; 利用斜抛运动轨迹画抛物线斜抛运动坐标计算公式： $ x = v_0 t cosθ, y = v_0 t sinθ - \\frac{g t^2}{2} $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;cmath&gt;using namespace std;struct Trajectory &#123; double x, y; char c; Trajectory() &#123; x = 0, y = 0; c = 'o'; &#125; Trajectory(double x, double y) : x(x), y(y) &#123; c = 'o'; &#125; void init(double x, double y) &#123; x = x, y = y; &#125;&#125;;void pos(short x, short y)&#123; HANDLE winHandle; COORD pos = &#123; x, y &#125;; winHandle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(winHandle, pos);&#125;void movement(Trajectory &amp;s, double v, double theta, double g, double t)&#123; double v_y = v * sin(theta); double v_x = v * cos(theta); double maxhigh = v_y * v_y / g - (v_y * v_y) / (2 * g); for (double i = 0; i &lt;= t; i += 0.1) &#123; pos(s.x, maxhigh - s.y); cout &lt;&lt; s.c; s.y = v_y * i - g * i*i / 2; s.x = v_x * i; // cout &lt;&lt; s.x &lt;&lt; \",\" &lt;&lt; s.y &lt;&lt; endl; Sleep(t * 20); &#125;&#125;int main()&#123; Trajectory s; movement(s, 18., 3.14 / 6., 2.8, 8.); return 0;&#125; t = 0.1 t = 0.5 贝塞尔曲线贝塞尔曲线二次方程： $ B(t) = (1 - t)^2 P_0 + 2 (1 - t) P_1 + t^2 P_2, \\quad 0 \\leq t \\leq 1 $","path":"2018/08/21/parabola/","date":"08-21","excerpt":""},{"title":"Kosaraju's algorithm","text":"算法简介该算法可以用来求解一个有向图的强连通分量。 算法解析什么是强连通分量？ 先说说强连通图：在有向图G中，如果任意 u,v 两顶点间连通，则称 (u,v) 强连通，则图G的一个强连通图，强连通图的极大强连通子图（强连通分量）就是其本身。 根据上面的说法，如果向图G中添加x个额外节点，使得有向图G不再是强连通图，则存在强连通分量。 下面考虑下图 （不知道怎么用graphviz把节点位置弄得更好看一点，将就着看吧） 手工字符版： 12341 &lt;--&gt; 2 --&gt; 3 ↖ | \\ ↓ 4 该图的强连通分量个数为：1，因为任意两顶点都能相互到达。 再举例： 12341 &lt;--&gt; 2 --&gt; 3 | ↓ 4 该图的强连通分量个数为：3，图中(1,2)、(3)、(4)都是强连通分量。 明白了强连通分量后，再来看算法。 以为例，我们得到它的邻接矩阵： 它的逆图及邻接矩阵： 算法首先对原图进行DFS遍历，然后将所有顶点加入到栈中，然后再将栈中的顶点倒出，从倒出的顶点对逆图进行遍历，如果任意两顶点相连通，则DFS2只调用一次就可以遍历逆图中所有顶点。如果出现不相互连通的顶点，则对逆图的遍历就会在中途中止，并通过栈中倒出的顶点来遍历完所有顶点。 现在来考虑核心算法部分的最坏情况的时间复杂度。 最坏情况时，显然所有顶点都是孤立的，算法开始时调用memset()，耗费 $ O(V) $，接下来调用DFS1()，无论原图是否为强连通图，DFS1()都将耗费 $ O(V^2) $，然后再次调用memset()，耗费 $ O(V) $，最后while()循环在最坏情况下将对每个顶点调用一次DFS2()，耗费 $ O(V^2) $。所以算法的时间总消耗为 $ O(V + V^2 + V + V^2) = O(V^2) $，这是使用邻接矩阵表示图时的时间复杂度。 使用邻接链表表示图时的时间复杂度为 $ O(V + E) $ 的线性时间。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int map[511][511];int nmap[511][511];int visited[501];stack&lt;int&gt; S;int N;void DFS1(int v)&#123; visited[v] = 1; for (int i = 1; i &lt;= N; i++) if (!visited[i] &amp;&amp; map[v][i]) DFS1(i); S.push(v);&#125;void DFS2(int v)&#123; visited[v] = 1; for (int i = 1; i &lt;= N; i++) if (!visited[i] &amp;&amp; nmap[v][i]) DFS2(i);&#125;int kosaraju()&#123; memset(visited, 0, sizeof(visited)); for (int i = 1; i &lt;= N; i++) if (!visited[i]) DFS1(i); int t = 0; memset(visited, 0, sizeof(visited)); while (!S.empty()) &#123; int v = S.top(); S.pop(); // printf(\"|%d|\", v); if (!visited[v]) &#123; t++; DFS2(v); &#125; &#125; return t;&#125;int main()&#123; int M, s, e; scanf_s(\"%d %d\", &amp;N, &amp;M); // 顶点及边个数 memset(map, 0, sizeof(map)); memset(nmap, 0, sizeof(nmap)); for (int i = 0; i &lt; M; i++) &#123; scanf_s(\"%d %d\", &amp;s, &amp;e); map[s][e] = 1; nmap[e][s] = 1; &#125; printf(\"\\n%d\\n\", kosaraju()); return 0;&#125; 参考1.Kosaraju’s algorithm - wikipedia","path":"2018/08/17/kosaraju-s-algorithm/","date":"08-17","excerpt":""},{"title":"牛顿法(Newton's method)","text":"算法简介感觉是老生常谈的算法了（其实咱就是来水一下&gt; &lt;）。但还是稍微说一下这个算法：对于形如 $ y = f(x) = 0 $ 这样的方程，初中的时候大部分的方程我们都可以使用求根公式解决，但实际上有许多方程我们很难求出它的根，于是只能用数值分析方法来逼近根值。基本原理:设 $ y=f(x) $ 在 $ x \\in [a,b] $ 上连续，如果有 $ f(a)*f(b) &lt; 0 $ ，则 $ f(x), x \\in (a, b) $ 一定过零点（记不得叫啥定理了，好像叫费马引理。至于为什么，画个图就很容易明白了。），那么 $ f(x) $ 在点 $ x_0, (a &lt; x_0 &lt; b)$ 处的切线方程也过零点，根据 $ f(x) $ 曲线的类型：递增、递减、凸或凹，我们会发现起点的选择对于切线随着点向根方向移动时的效率也是不同的。 比如：若 $ x \\in [a, b], f(a) &lt; 0, f(b) &gt; 0, f’’(x) &lt; 0 $ 时，起点应从a点开始迭代效率会更高，即考察 $ f(a) $ 与 $ f’’(x) $ 是否同号，如果同号，则a点为起点，否则b点为起点。 总之，根据 $ y = f(x) $ 在 $ x_0 $ 处求出切线方程有： f(x) - f(x_0) = f'(x_0)(x - x_0)由于 $ f(x) = 0 $，所以有： x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)}再在点 $ (x_1, f(x_1)) $ 作切线，可得根得近似值 $ x_2 $.如此反复进行，一般的，在点(x_{n-1}, f(x_{n-1}))作切线，最终可得到迭代方程： x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}算法原理参考：高等数学。 想要再详细了解的同学可以看看：Newton’s method 算法实现这里我使用函数指针方式来保证接口使用的便利性，虽然可变长参数还没做处理，这一点有空再完善吧。。。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;typedef double(*equaton)(double x, ...);double square(double x)&#123; return x * x;&#125;double func1(double x, ...)&#123; return square(x)*x + square(x) - 1.;&#125;double func2(double x, ...)&#123; return 3 * square(x) + 2 * square(x);&#125;double newton_method(equaton func, equaton der_func, double a, double b, bool isbump, double λ) // isbump： 凹 is true; 凸 is false&#123; if (func(a)*func(b) &gt;= 0) return 0.0; double x, pre_x; if (func(a) &gt; 0 &amp;&amp; isbump) x = a; else x = b; do &#123; pre_x = x; x -= func(x) / der_func(x); &#125; while (abs(func(x)) &gt; λ &amp;&amp; fabs(pre_x - x) &gt; λ); return x;&#125;int main()&#123; std::cout &lt;&lt; \"方程的根为：\" &lt;&lt; newton_method(func1, func2, 0., 1., true, 1e-6) &lt;&lt; std::endl; return 0;&#125; 测试： $ f(x) = x^3 + x^2 - 1 $ output: 1方程的根为：0.754878 更新：增加了两个函数，一个是 $ f(x) $ 的二阶导函数，一个是判断原函数凹凸。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;typedef double(*equaton)(double x, ...);double square(double x)&#123; return x * x;&#125;double func1(double x, ...)&#123; return cos(x) - square(x)*x;&#125;double func2(double x, ...)&#123; return -sin(x) - 3 * square(x);&#125;double func3(double x, ...)&#123; return -cos(x) - 6 * x;&#125;bool isbump(double a, double b)&#123; for (double i = a; i &lt;= b; i += 1e-2) if (func3(i) &lt; 0.) return false; return true;&#125;double newton_method(equaton func, equaton der_func, double a, double b, bool isc, double λ) // isc： 凹 is true; 凸 is false&#123; if (func(a)*func(b) &gt;= 0.) return 0.0; double x, pre_x; if (func(a) &gt; 0 &amp;&amp; isc) x = a; else x = b; do &#123; pre_x = x; x -= func(x) / der_func(x); &#125; while (abs(func(x)) &gt; λ &amp;&amp; fabs(pre_x - x) &gt; λ); return x;&#125;int main()&#123; std::cout &lt;&lt; \"方程的根为：\" &lt;&lt; newton_method(func1, func2, 0., 1., isbump(0., 1.), 1e-6) &lt;&lt; std::endl; return 0;&#125; 测试： $ f(x) = cos(x) - x^3 $ output: 1方程的根为：0.865474 关于牛顿法开方（或任意次方）算法，强烈推荐看看这个回答：https://www.guokr.com/question/461510/ 简单提一下需要注意得地方：求 $ \\sqrt{2} $ 时，考虑有 $ x^2 - a = 0 $，即 $ x = \\pm \\sqrt{a} $，于是 $ x $ 就是迭代公式中的 $ x_i $，$ a = 2 $ 就是我们要求的。回答中给出了求任意次方时的公式，直接套用即可。 开方代码实现： 1234567891011121314#include &lt;iostream&gt;int main()&#123; double x, pre_x; x = 1; pre_x = 9999; while (fabs(pre_x - x) &gt; 0) &#123; pre_x = x; x = (x + (2 / x)) / 2; &#125; std::cout &lt;&lt; x &lt;&lt; std::endl; return 0;&#125; 牛顿法求 $ x^n $ 算法实现（代码有误）： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;double newton_method_power(double a, double b)&#123; if (a == 0.) return 0.; else if (a == 1. || b == 0.) return 1.; else if (b == 1.) return a; else if (fabs(b) &gt; 1.) return 0.; // 当指数|b| &gt; 1 且为整数时,使用快速幂算法；为浮点数时，可以使用微分近似法或泰勒公式求解 else &#123; b = 1./b; double x, pre_x; x = 1.; pre_x = 9999.; while (fabs(pre_x - x) &gt; 0.) &#123; pre_x = x; x = ((b - 1.)*x / b) + (a / (b*newton_method_power(x, b - 1.))); &#125; return x; &#125;&#125;int main()&#123; std::cout &lt;&lt; newton_method_power(8., 1.) &lt;&lt; std::endl; return 0;&#125; 微分近似公式： f(x + \\Delta x) \\approx f(x) + f'(x) \\cdot \\Delta x例如： 1.求 $ 2^{1.4} $ 由 $ f(x) = a^x $，$ f(x + \\Delta x) = a^{x + \\Delta x} \\approx a^{x} + a^{x} ln(a) \\cdot \\Delta x $有 $ 2^{1 + 0.4} \\approx 2 + 2ln(2) \\cdot 0.4 \\approx 2.554518… $而原表达式 $ 2^{1.4} = 2.63902… $ 2.求 $ 2^{9} $ 利用公式有 $ 2^{10 - 1} = (2^{10})^{(1 - \\frac{1}{10})} \\approx 2^{10} + 2^{10} ln(2^{10}) \\cdot 0.1 \\approx 709.783… $$ 2^9 = 512 $ 参考1.Newton’s method - wikipedia2.果壳网","path":"2018/08/04/newton-s-method/","date":"08-04","excerpt":""},{"title":"汉明距离(hamming distance)","text":"简介看knn算法时无意间发现这个算法，但是维基上有错误的示例和python代码。。。因为汉明距离并不是求相同长度字符串（或相同长度的整数）之间的字符（或数位）差异个数。 正确的详见：https://en.wikipedia.org/wiki/Talk:Hamming_distance 然而，我发现百度百科和一些博客都是参考的汉明距离 - 维基百科，所以都错了 = =。。。 认真分析正确代码后，我认为汉明距离指的是将两个字符串或两个整数编码为一组二进制数，然后计算两二进制bit之间的差异个数。 维基上有人也发现这个问题并给了一个正确的python代码： 1234567891011121314s1 = &apos;karolin&apos;s2 = &apos;kerstin&apos;def hamming_distance(s1, s2): b1, b2 = bytearray(s1, encoding=&apos;utf8&apos;), bytearray(s2, encoding=&apos;utf8&apos;) diff = 0 for i in range(len(b1)): if b1[i] != b2[i]: diff += bin(b1[i] ^ b2[i]).count(&quot;1&quot;) return diffprint(hamming_distance(s1, s2)) C/C++： 12345678910111213141516171819#include &lt;iostream&gt;#define ull unsigned long longint hamming_distance(ull x, ull y)&#123; int dist = 0; ull or = x ^ y; while (or) &#123; dist++; or &amp;= or - 1; &#125; return dist;&#125;int main()&#123; ull x, y; while (std::cin &gt;&gt; x &gt;&gt; y) std::cout &lt;&lt; \"最小汉明距离为：\" &lt;&lt; hamming_distance(x, y) &lt;&lt; std::endl; return 0;&#125; 以C代码为例，比如两个整数：1, 2，他们的二进制分别为 001, 010 ，从 001 → 010 最少需要2步替换，也就是最小汉明距离为2；又比如两整数：12, 34，他们的二进制分别为 001100, 100010，001100 → 100010 的最小汉明距离为4。 运行示例： 注：第三个可以自己动手验证一下~ 然后维基上还有一段代码： 123456789int hamming_distance(unsigned x, unsigned y)&#123; return __builtin_popcount(x ^ y);&#125;//if your compiler supports 64-bit integersint hamming_distance(unsigned long long x, unsigned long long y)&#123; return __builtin_popcountll(x ^ y);&#125; 好像我的电脑上不行，没有__builtin_popcountll()函数。","path":"2018/08/04/hamming-distance/","date":"08-04","excerpt":""},{"title":"线段树（Segment tree）","text":"参考github-consmos 博客园-TenosDoIt 算法解析关于线段树详细释义请见：博客园-darkchii 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#define LC(i) ((i) &lt;&lt; 1)#define RC(i) ((i) &lt;&lt; 1 | 1)#define M 10010#define min(a, b) ((a) &lt; (b) ? (a) : (b))struct &#123; int l, r, val; &#125; SegTree[M];int num[] = &#123; 18, 17, 19, 13, 15, 11, 20 &#125;;void build(int l, int r, int k)&#123; if (l == r) SegTree[k].val = num[l]; else &#123; int m = (l + r) &gt;&gt; 1; build(l, m, LC(k)); build(m + 1, r, RC(k)); SegTree[k].val = min(SegTree[LC(k)].val, SegTree[RC(k)].val); &#125;&#125;void update(int l, int r, int k, int pos, int v)&#123; if (l &gt; pos || r &lt; pos || r &lt; l) return; if (l == r) &#123; SegTree[k].val = v; return; &#125; int m = (l + r) &gt;&gt; 1; if (pos &lt;= m) update(l, m, LC(k), pos, v); else update(m + 1, r, RC(k), pos, v); SegTree[k].val = min(SegTree[LC(k)].val, SegTree[RC(k)].val);&#125;int query(int l, int r, int x, int y, int k)&#123; if (l &gt; r || l &gt; y || r &lt; x) return M; if (x &lt;= l &amp;&amp; r &lt;= y) return SegTree[k].val; int m = (l + r) &gt;&gt; 1; return min(query(l, m, x, y, LC(k)), query(m + 1, r, x, y, RC(k)));&#125;int main()&#123; int len, x, y, k, v; len = (sizeof(num) / sizeof(int)) - 1; build(0, len, 1); for (int i = 1; i &lt;= 2 * len; i++) std::cout &lt;&lt; SegTree[i].val &lt;&lt; ' '; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"查询[x,y]区间的最小值：\" &lt;&lt; std::endl; std::cin &gt;&gt; x &gt;&gt; y; std::cout &lt;&lt; query(0, len, x, y, 1) &lt;&lt; std::endl; std::cout &lt;&lt; \"更新下标k位置上的值：\" &lt;&lt; std::endl; std::cin &gt;&gt; k &gt;&gt; v; update(0, len, 1, k, v); for (int i = 1; i &lt;= 2 * len; i++) std::cout &lt;&lt; SegTree[i].val &lt;&lt; ' '; std::cout &lt;&lt; std::endl; return 0;&#125;","path":"2018/08/01/segment-tree/","date":"08-01","excerpt":""},{"title":"树状数组（Fenwick tree）","text":"参考fenwick tree 算法实现12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#define LSB(i) (i &amp; -i)const int M = 10001;int bit_tree[M];int freq[M];int getsum(int index)&#123; int sum = 0; for (index += 1; index &gt; 0; index -= LSB(index)) sum += bit_tree[index]; return sum;&#125;void update(int n, int index, int val)&#123; for (index += 1; index &lt;= n; index += LSB(index)) bit_tree[index] += val;&#125;void init(int freq[], int n)&#123; for (int i = 1; i &lt;= n; i++) bit_tree[i] = 0; for (int i = 0; i &lt; n; i++) update(n, i, freq[i]);&#125;int main()&#123; int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; freq[i]; init(freq, n); for (int i = 0; i &lt; n; i++) std::cout &lt;&lt; getsum(i) &lt;&lt; std::endl; for (int i = 1; i &lt;= n; i++) std::cout &lt;&lt; bit_tree[i] &lt;&lt; ' '; return 0;&#125;","path":"2018/08/01/fenwick-tree/","date":"08-01","excerpt":""},{"title":"计划","text":"前言拟（立）一个学习计划（flag）。 学习计划 注：其中删除线表示已完成。 算法（持续学习中…） A*算法 红黑树的删除维护部分 正则表达式 最坏时间复杂度O(n)的选择算法 数学类算法 符号计算 复变函数 图论 最小生成树 最短路径 哈密顿回路 欧拉回路 动态规划 图形学 OJ codeforces poj hdu 洛谷 编程语言 深入C++各种细节 Haskell Lisp Python MatLab Mathematics JavaScript 汇编语言（入门） 想弄懂的 函数式编程 图灵机 λ calculus Process calculus 书籍 深入理解计算机操作系统(CSAPP) 计算机程序的构造与解释(SICP) 统计学习方法 游戏引擎架构 离散数学 高等代数 信号与系统 狼与香辛料 C-libhttp项目 简易Json解析库 图片/音频/视频等处理 http协议 研究源码 STL boost Linux内核 you-get（python package） 技术方向 机器学习 深度学习 编译原理 搜索引擎 网络安全 github个人仓库 重构以前写的抓取Pixiv的代码 整合/整理一些仓库代码 人类语言 英语 日语 国语 自然科学 数学 高数 数分 线代 高代 抽象代数 概率论 复变函数 离散数学 数理逻辑（与计算机相关方向） 集合论 证明论 范畴论 模型论 递归论 实变函数 实分析与复分析 物理 天文学 弹道学 法医学 经济学 考古学","path":"2018/07/29/planning-or-flag/","date":"07-29","excerpt":""},{"title":"并查集","text":"About algorithmUnion-Find algorithm(also called a Disjoint-set or Merge find algorithm) is a very useful data structure. ReferencesRecommend to see this document:Union-Find.pdf Algorithm implementationBelow is an algorithm I implemented in C Programming language: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;const int N = 10010;int id[N];void init()&#123; for (int i = 0; i &lt; N; i++) id[i] = i;&#125;int find(int r)&#123; while (id[r] != r) r = id[r]; return r;&#125;void transplant(int i) // path compression&#123; int r = find(i); while (i != r) &#123; int p = id[i]; id[i] = r; i = p; &#125;&#125;bool issmooth(int p, int q)&#123; return find(p) == find(q);&#125;void join(int p, int q)&#123; int r1 = find(p), r2 = find(q); if (r1 != r2) id[r1] = r2;&#125;int main()&#123; init(); for (int i = 0; i &lt; 8; i++) cout &lt;&lt; i &lt;&lt; \"-&gt;\" &lt;&lt; id[i] &lt;&lt; ' '; join(1, 2); join(1, 3); join(2, 4); join(5, 6); join(6, 7); join(6, 8); if (issmooth(2, 7)) cout &lt;&lt; \"true\" &lt;&lt; endl; else cout &lt;&lt; \"false\" &lt;&lt; endl; transplant(1); for (int i = 0; i &lt; 8; i++) cout &lt;&lt; i &lt;&lt; \"-&gt;\" &lt;&lt; id[i] &lt;&lt; ' '; getchar(); return 0;&#125;/* 1--2--4 | / |/ 3 5--6--7 | 8*/","path":"2018/07/28/union-find/","date":"07-28","excerpt":""},{"title":"梯度下降算法","text":"补充说明代码更新了，为了解释为什么代码这样写，先来说说梯度下降法的迭代公式。 首先，暂时只考虑二元函数 $ f(x, y) $，因为在能可视化的三维图下研究梯度更好理解，但在文章中形式上我还是把它考虑写为 $ f(\\vec x) $。 设函数为 $ f(\\vec x) = ag(x_1) + b\\phi{(x_2)} + c $ 函数从某个起点 $ \\vec{p}_{(1)} = (p_1, p_2) $ 处出发，通过求梯度进行方向搜索，找到某个步长范围内下降最快的方向的点，然后从初始点移动到找到的点。 迭代公式： \\vec{p_{n + 1}} = \\vec{p_{n}} + \\lambda \\dot (-\\bigtriangledown f(\\vec x))这里 $ \\lambda $ 是一个步长系数，我们可以自己控制它的增长，它的作用就在于有时候如果步长设置过大，可能就会跳过我们要走的方向，过小可能完全找不到方向，所以还有更好的自动计算方式： 我们的迭代公式求出来的是一个点，于是将 $ \\vec{x{n}} + \\bigtriangledown f(\\vec x) \\dot \\lambda $ 代入原函数中，得到： \\omega (\\lambda)) = ag(p_1 + \\lambda \\dot (-\\bigtriangledown f(\\vec{p}_{(1)}))) + b\\phi{(p_2 + \\lambda \\dot (-\\bigtriangledown f(\\vec{p}_{(1)})))}令 $ \\omega ‘(\\lambda) = 0 $ ，整理得： a^2 g'(p_1) g'(p_1 - a\\lambda g'(p_1)) + b^2 \\phi '(p_2) \\phi '(p_2 - b\\lambda \\phi '(p_2)) = 0因为参数a,b和点(p_1, p2)都已知，所以可求出 $ \\lambda $ 的值，这就是我代码中ployeq()函数的意义。 本来为了便利性，所以利用回调函数gradient_eq来方便自己定制方程的梯度公式，做了种种尝试后发现，不会符号计算还是不能便利的求ployeq()函数，因为λ是一个未知变量，不好代公式求出来。。。所以，想求方程，还是只有麻烦自己先手动推出计算公式啦~ 关于算法Gradient descent 又叫最速下降法，是一种局部搜索算法，属于智能算法，类似的有爬山算法、模拟退火等。基本原理是优化理论中的无约束问题，利用梯度搜索函数变化最快的方向，然后不断迭代的方法。 好久之前学过这个算法，但当时没实际写过代码，仅仅推过公式，然后做了一道题。。。后来一直没用上，就忘了一些推导过程了。。。 今天有点晚，暂时就不详细推公式了，有空我将补上推导过程并给出梯度法的收敛条件，还会给出一些更好的优化算法(牛顿法、共轭梯度法等)及其他约束问题的优化算法，届时我们将会看到许多有趣的搜索算法，比如斐波那契法、黄金比例法(0.618法)等。 代码实现由于咱太蒻稽…不会符号计算，不能写一个通用梯度下降算法模板。。。于是这里以问题 min \\ f(x) = 2x_1 ^2 + x_2 ^2,起始点 $ x_0 = (1, 1)^T, \\epsilon = \\frac{1}{1000} $ 为例。 函数图： 算法实现： C programming language12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define square(x) x*xtypedef double(*gradient_eq)(double, ...);double partial_x(double x, ...)&#123; return 4*(-x);&#125;double partial_y(double x, ...)&#123; return 2*(-x);&#125;double hypotenuse(double a, double b)&#123; return sqrt(square(a) + square(b));&#125;double ployeq(double x_1, double x_2, double a, double b)&#123; return -(2*a*x_1 + b*x_2)/(2*square(a) + square(b));&#125;void gradient_descent( double x_1, double x_2, gradient_eq grad_x, gradient_eq grad_y, double epsilon, unsigned max_iters)&#123; double a, b, lambda; unsigned iters = 0; do &#123; printf (\"(%f, %f)\\n\", x_1, x_2); a = grad_x(x_1), b = grad_y(x_2); lambda = ployeq(x_1, x_2, a, b); x_1 += a*lambda; x_2 += b*lambda; iters++; &#125; while (hypotenuse(a, b) &gt; epsilon &amp;&amp; iters &lt; max_iters);&#125;int main()&#123; double x_1 = 1., x_2 = 1.; gradient_descent(x_1, x_2, partial_x, partial_y, 1e-3, 100); return 0;&#125; Output: $ \\epsilon = 10^-3 $ 12345678(1.000000, 1.000000)(-0.111111, 0.444444)(0.074074, 0.074074)(-0.008230, 0.032922)(0.005487, 0.005487)(-0.000610, 0.002439)(0.000406, 0.000406)(-0.000045, 0.000181) $ \\epsilon = 10^-6 $ 12345678910111213141516(1.000000, 1.000000)(-0.111111, 0.444444)(0.074074, 0.074074)(-0.008230, 0.032922)(0.005487, 0.005487)(-0.000610, 0.002439)(0.000406, 0.000406)(-0.000045, 0.000181)(0.000030, 0.000030)(-0.000003, 0.000013)(0.000002, 0.000002)(-0.000000, 0.000001)(0.000000, 0.000000)问题最优解：(0, 0) Python31234567891011121314151617181920212223square = lambda x: x ** 2side = lambda a, b: (a ** 2 + b ** 2) ** (1 / 2)def d(x_1, x_2): return -4 * x_1, -2 * x_2def evaluate(x_1, x_2, a, b): return -(2 * a * x_1 + b * x_2) / (2 * square(a) + square(b))def gradient_descent(x_1, x_2, epsilon, max_iters): iters = 0 a, b = 1, 1 while (side(a, b) &gt; epsilon) &amp; (iters &lt; max_iters): print('%d (%.6f, %.6f)' % (iters + 1, x_1, x_2)) a, b = d(x_1, x_2) gamma = evaluate(x_1, x_2, a, b) (x_1, x_2) = (x_1 + a * gamma, x_2 + b * gamma) iters += 1if __name__ == '__main__': gradient_descent(1, 1, 0.001, 100) Output: 123456781 (1.000000, 1.000000)2 (-0.111111, 0.444444)3 (0.074074, 0.074074)4 (-0.008230, 0.032922)5 (0.005487, 0.005487)6 (-0.000610, 0.002439)7 (0.000406, 0.000406)8 (-0.000045, 0.000181) matlabmatlab版的有点问题。。 12345678910111213141516171819202122232425262728293031323334clc;clear;e = 1e-3;x0 = [1 1];max_iters = 100;gradient_descent_algorithm(e, x0, max_iters);function gradient_descent_algorithm(epsilon, x0, max_iters)f = @(p) 4 * p(1) + 2 * p(2);[x,y] = meshgrid(-2:0.1:2);z = 2 * x.^2 + y.^2;figuresurfc(x,y,z);xlabel('x');ylabel('y');zlabel('z');[zx,zy] = gradient(z);d = -x0;iters = 0;while sqrt(d * d') &gt; epsilon &amp;&amp; iters &lt; max_iters inat = find(x == x0(1) &amp; y == x0(2)); d = -[zx(inat) zy(inat)]; disp(d); syms c; l = f(x0 + c*d) == 0; lambda = solve(l, c); x0 = x0 + lambda*d; iters = iters + 1;endend% function draw_search()%% end 参考文献1.《最优化理论与算法 第二版》・陈宝林2.Gradient descent - wikipedia","path":"2018/07/26/gradient-descent/","date":"07-26","excerpt":""},{"title":"轻量级Json解析器","text":"更新日志该项目更新日志历史按最新时间排序。 Update 2018-10-12此次更新的主要内容 修复了TextChecker()、Erase()、ToString()的bug; 增加了ToHttpRequestHeader()功能，用于将json文本解析为http协议请求头部格式； Text类中增加了RemovePair()功能，与Journey类中的Erase()功能相同，都是用于移除一对key-value。 Update 2018-10-09此次更新的主要内容 增加了TextChecker()api，其作用是检测json文本是否合法。用法 123Text t;const char*s = \"&#123;\\\"hello\\\":\\\"world\\\",\\\"\\\":&#123;\\\"112\\\":\\\"few\\\",\\\"er\\\":[1,2,3]&#125;&#125;\";std::cout &lt;&lt; (t.TextChecker(s) ? \"true\" : \"false\") &lt;&lt; std::endl; 改变了一些api的名称，比如之前的JsonFormatPrint改为了Output、WriteText改为了WriteToText、Tojson改为了ToString，两个类中获取对象名称分别改为了GetValueIsObject、GetPair等。 增加了生成器Journey类，将基础类型值数据结构从Value类中拿了出来，并做了许多赋值运算符=与中括符[]的重载。使得使用更方便。用法见：生成器用例 接下来打算添加迭代器。 源码见：libjson.hpp Update 2018-10-07pm 12:23此次更新的主要内容 增加了对解析好的文本的可操作性（增删改查等），示例见：example 完善了之前一些没注意到的问题。 Update 2018-10-05pm 02:52此次更新的主要内容 完善了之前一些没注意到的问题。 Update 2018-10-05pm 07:44此次更新的主要内容 重新设计了数据结构，让数据使用变得更安全； 修复了字符串转浮点型算法的bug，目前是这样的: 1234567891011double str2dou(std::string s)&#123; double num = 0, point_back = 0, sign = 1; size_t i = 0, pos = 0; if (s[i] == &apos;-&apos;) i++, sign *= -1; while (s[i] != &apos;.&apos;) num = num * 10 + (s[i++] - &apos;0&apos;); pos = i++; while (s[i]) point_back = point_back * 10 + (s[i++] - &apos;0&apos;); num += point_back / std::pow(10, i - pos - 1); return num * sign;&#125; 更换了解析方式，之前的解析的json格式： 12345678&#123; &quot;string&quot;: &quot;hello&quot;, &quot;double&quot;: &quot;-123.43&quot;, &quot;int&quot;: &quot;10&quot;, &quot;bool&quot;: &quot;true&quot;, &quot;null&quot;: &quot;null&quot;, &quot;array&quot;: &quot;[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;]&quot;&#125; 现在的：12345678&#123; &quot;string&quot;: &quot;hello&quot;, &quot;double&quot;: -123.43, &quot;int&quot;: 10, &quot;bool&quot;: true, &quot;null&quot;: null, &quot;array&quot;: [2, 3, 4]&#125; 去掉一些多余的变量； 解析器的使用：1234567891011121314151617#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include \"libjson.h\"using namespace std;int main()&#123; Text t; fstream text(\"json.txt\", fstream::in | fstream::out | fstream::app); string line, str; while (getline(text, line)) str += line; text.close(); t.Parse(str); t.JsonFormatPrint(); return 0;&#125; output:123456&#123; &quot;Latin_Modern&quot; : &quot;fn_lm&quot;, &quot;Verdana&quot; : &quot;fn_jvn&quot;, &quot;time&quot; : -123.23, &quot;flag&quot; : true&#125; 决定将解析器与生成器分离开，这样更易于使用和维护。（目前基本上完成了解析器部分，生成器正在进行中） Update 2018-09-28pm 07:55此次更新的主要内容 利用其他方式完善了 add()、setvalue()，还有 operator[]，解决了不同类型的传值的增改功能（虽然比较方法比较笨拙）。 完善了不同类型转换为 string 的算法，这些都是是辅助算法，应考虑单独放在一个头文件中调用。 需要注意的地方： add、setvalue函数只能传入两个字符串，不管 value 是什么类型都使用字符串进行传入。用例： 1234567891011121314r.add(\"string\", \"yes\"); // `value`为字符串类型r.set(\"string\", \"no\"); // 同上r.add(\"array\", \"[\\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\", \\\"five\\\"]\"); // `value`为字符串数组类型r.setvalue(\"array\", \"[\\\"Json\\\", \\\"Test\\\", \\\"Fuck\\\"]\"); // 同上r.add(\"double\", \"324.23\"); // `value`为浮点类型r.setvalue(...); // 同上r.add(\"bool\", \"true\"); // `value`为布尔类型r.setvalue(...); // 同上r.add(\"root\", \"&#123;\\\"parent\\\":\\\"children\\\"&#125;\")// `value`为Json对象类型r.setvalue(..); // 同上 通过 []，获取的 value 不是原地址，所以不能进行赋值或修改。也暂不能获取对象类型。getvalue() 暂且保留原样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_t#define ll long long#define index(c) (c - 'A')const int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;st weight(const char*s)&#123; st i = 0, x = 0; while (s[i]) x += index(s[i])*i, i += 1; return x + i;&#125;void bits(char s[], st &amp;i, ll x)&#123; if (!x) return ; bits(s, i, x/10); s[i++] = x%10 + '0';&#125;void bits(std::string &amp;s, st &amp;i, ll x)&#123; if (!x) return ; bits(s, i, x/10); s[i++] = x%10 + '0';&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;const char* bool2con_ch_arr(bool v)&#123; if (v) return \"true\"; return \"false\";&#125;ll con_char2int(const char *s)&#123; ll num = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s) num = num * 10 + (*s - '0'); return num*sign;&#125;ll str2int(std::string s)&#123; return con_char2int(s.c_str());&#125;std::string int2str(ll num)&#123; std::string s; st i = 0; if (num &lt; 0) s += \"-\", i++; bits(s, i, num); return s;&#125;const char* int2con_ch_arr(ll num)&#123; return int2str(num).c_str();&#125;double str2float(const char*s, st p, st r)&#123; double num = 0, propoint = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num*sign;&#125;double str2dou(const char*s) // 与 str2float() 功能一样&#123; double num = 0, propoint = 0, sign = 1; st i = 0, pos = 0; if (s[i] == '-') i++, sign *= -1; while (s[i] != '.') num = num * 10 + (s[i] - '0'), pos = i++; i++; while (s[i]) propoint = propoint * 10 + (s[i] - '0'); num += propoint / std::pow(10, i - pos); return num*sign;&#125;char* float2ch_arr(double num)&#123; char*s = new char; st i = 0; if (num &lt; 0) s[i++] = '-', num *= -1; ll x = (ll)num; double y = num - x; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1)%10 + '0'; &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;const char* float2con_ch_arr(double num)&#123; return (const char*)float2ch_arr(num);&#125;std::string float2str(double num)&#123; std::string s(float2con_ch_arr(num)); return s;&#125;void str2arr(std::vector&lt;std::string&gt;&amp; arr_str, const char*s)&#123; std::string str; st i = 0; while (*s) &#123; switch(*s) &#123; case ',': if (i &gt; 0) &#123; str[i] = '\\0'; arr_str.push_back(str); i = 0; &#125; break; case ' ': break; default : str[i++] = *s; break; &#125; s++; &#125;&#125;const char* arr2con_ch_arr(std::vector&lt;std::string&gt; arr_str)&#123; char*s = new char; st k = 0; for (st i = 0; i &lt; arr_str.size(); i++) &#123; for (st j = 0; j &lt; arr_str[i].size(); j++) s[k++] = arr_str[i][j]; if (i != arr_str.size() - 1) s[k++] = ','; &#125; s[k] = 0; return (const char*)s;&#125;class BaseNode &#123;public: bool b_v; ll i_v; double d_v; std::string s_v; std::vector&lt;std::string&gt; arr_v; std::string key; st keys; bool isvalue; Type type; ll table[N]; BaseNode *children[N], *parent; BaseNode() &#123; keys = 0, isvalue = false, type = OBJECT, parent = nullptr; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; BaseNode(BaseNode*p, const char *k) &#123; std::string sk(k); key = sk, keys = 0, isvalue = false, parent = p; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void print(BaseNode*r, int format) &#123; if (r) &#123; std::cout &lt;&lt; '&#123;' &lt;&lt; std::endl; for (st i = 0; i &lt; r-&gt;keys; i++) &#123; BaseNode*node = r-&gt;children[i]; if (node) &#123; for (int j = 0; j &lt; format; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;key &lt;&lt; \"\\\" : \"; switch (node-&gt;type) &#123; case BOOL: std::cout &lt;&lt; (node-&gt;b_v ? \"true\" : \"false\"); break; case INTEGER: std::cout &lt;&lt; node-&gt;i_v; break; case FLOAT: std::cout &lt;&lt; node-&gt;d_v; break; case STRING: std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;s_v &lt;&lt; \"\\\"\"; break; case ARRAY: std::cout &lt;&lt; '['; for (st j = 0; j &lt; node-&gt;arr_v.size(); j++) &#123; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; \"\\\"\"; if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; \", \"; &#125; std::cout &lt;&lt; ']'; break; case OBJECT: print(r-&gt;children[i], format + 1); break; &#125; if (i != root-&gt;keys - 1) std::cout &lt;&lt; \",\"; std::cout &lt;&lt; std::endl; &#125; &#125; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; '&#125;' &lt;&lt; std::endl; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; &#125; &#125; BaseNode* findkey(BaseNode*r, const char*s) &#123; if (r &amp;&amp; r-&gt;table[weight(s)] != -1) return r-&gt;children[r-&gt;table[weight(s)]]; return nullptr; &#125; void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(std::string s) &#123; parse(s.c_str()); &#125; void parse(const char *s) &#123; char str[N]; st i = 0; bool arr_sw = false, obj_sw = false, str_sw = false; if (!root) root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (obj_sw) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; &#125; break; case '&#125;': nd-&gt;isvalue = false; nd = nd-&gt;parent; obj_sw = false; break; case '\"': if (str_sw) str_sw = false; else str_sw = true; if (i &gt; 0) &#123; bool b = false; double dounum = 0; ll intnum = 0; st f = 0, pos = 0; str[i] = '\\0'; if (!arr_sw) &#123; if (i &lt; 11) &#123; if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); else &#123; for (st j = 0; j &lt; i; j++) if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (st j = 0; j &lt; i; j++) if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; &#125; &#125; &#125; else f = 4; if (nd-&gt;isvalue) &#123; if (nd-&gt;children[nd-&gt;keys - 1]) &#123; std::string ps(str); switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; case 4: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY; nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps); break; &#125; &#125; &#125; else &#123; if (nd-&gt;table[weight(str)] == -1) &#123; BaseNode *n = new BaseNode(nd, str); nd-&gt;children[nd-&gt;keys] = n; &#125; &#125; i = 0, obj_sw = true; &#125; break; case ':': if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; break; case ',': if (!arr_sw) &#123; nd-&gt;isvalue = false; if (str_sw) str[i++] = *s; &#125; break; case ' ': if (!arr_sw) if (str_sw) str[i++] = *s; break; case '[': arr_sw = true; break; case ']': arr_sw = false; break; case '/': if (str_sw) str[i++] = *s; break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; BaseNode*node = root-&gt;children[i]; std::string str = node-&gt;key; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; pstr += \"=\"; str.clear(); switch(node-&gt;type) &#123; case BOOL: if (node-&gt;b_v) str = \"true\"; else str = \"false\"; break; case INTEGER: str = int2str(node-&gt;i_v); break; case FLOAT: str = float2str(node-&gt;d_v); break; case STRING: str = node-&gt;s_v; break; default: std::cerr &lt;&lt; \"String parse error!\" &lt;&lt; std::endl; return \"\"; &#125; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125; auto getvalue(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123;// switch(node-&gt;type)// &#123;// case BOOL: return node-&gt;b_v;// case INTEGER: return node-&gt;i_v;// case FLOAT: return node-&gt;d_v;// case STRING: return node-&gt;s_v;// case ARRAY: return node-&gt;arr_v;// default: return node-&gt;children[node-&gt;table[weight(key)]];// &#125; return node-&gt;d_v; &#125; return 0.0; &#125; auto operator[](const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123; switch(node-&gt;type) &#123; case BOOL: return bool2con_ch_arr(node-&gt;b_v); case INTEGER: return int2con_ch_arr(node-&gt;i_v); case FLOAT: return float2con_ch_arr(node-&gt;d_v); case STRING: return node-&gt;s_v.c_str(); case ARRAY: return arr2con_ch_arr(node-&gt;arr_v); default: return \"\"; // default: return node-&gt;children[node-&gt;table[weight(key)]]; &#125; &#125; return \"\"; &#125; template&lt;class T&gt; T&amp; operator=(T v) &#123; return v; &#125; void setvalue(const char*key, const char*value) &#123; BaseNode*node = findkey(root, key); if (node) &#123; std::string document, k(key), v(value); document += \"&#123;\\\"\", document += k, document += \"\\\":\"; document += \"\\\"\" , document += v, document += \"\\\"&#125;\"; parse(document.c_str()); &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; void add(const char*key, const char*value) &#123; BaseNode*node = findkey(root, key); if (!node) &#123; std::string document, k(key), v(value); document += \"&#123;\\\"\", document += k, document += \"\\\":\"; document += \"\\\"\" , document += v, document += \"\\\"&#125;\"; parse(document.c_str()); &#125; else &#123; std::cerr &lt;&lt; \"The key was existed!\" &lt;&lt; std::endl; return; &#125; &#125; void erase(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123; BaseNode*p = node-&gt;parent; p-&gt;keys--; p-&gt;table[weight(node-&gt;key.c_str())] = -1; destory(node); &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; void visual() &#123; print(root, 1); &#125;&#125;;int main()&#123; JsonTree r; std::fstream context(\"json.txt\", std::fstream::in | std::fstream::out | std::fstream::app); std::string line, str; while (std::getline(context, line)) str += line; context.close(); r.parse(str); r.add(\"hello\", \"world\"); std::cout &lt;&lt; r[\"hello\"] &lt;&lt; std::endl; r.visual(); r.setvalue(\"hello\", \"[\\\"Json\\\", \\\"Test\\\", \\\"Fuck\\\"]\"); std::cout &lt;&lt; r[\"hello\"] &lt;&lt; std::endl; std::cout &lt;&lt; r[\"time\"] &lt;&lt; std::endl; r.visual(); return 0;&#125; output: 12345678910111213141516171819202122232425262728293031323334353637383940world&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"], &#125; , \"time\" : -123.23, \"flag\" : true, \"hello\" : \"world\"&#125;Json,Test,Fuck-123.230000000(&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"], &#125; , \"time\" : -123.23, \"flag\" : true, \"hello\" : [\"Json\", \"Test\", \"Fuck\"]&#125;&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"], &#125; , \"time\" : -123.23, \"flag\" : true, \"hello\" : [\"Json\", \"Test\", \"Fuck\"], \"root\" : &#123; \"parent\" : \"children\", &#125;&#125; am 04:00 左右此次更新的主要内容 修改了字符串加权函数名 has() 为 weight()，这样更合适。 前面代码中还有一个明显的安全隐患，那就是 weight() 函数的设计，因为考虑到一些字符的ascii码比字符A小，会出现负数，这时会出现数组越界问题。但我考虑暂不做更改，因为我默认所有的 key 都不会出现那些奇怪的字符。 完善了一些不合理的地方。 个人遇到的一些技术难点为了做出更好的Json解析器查了许多资料，但我有许多问题得不到解答。在C++中，不能对传参相同，返回类型不同的函数进行重载，模板也不能自动对返回类型进行推断（除非使用 C++11 auto 以及 C++14 编译器），这样我很难完成下面这样的功能：123container n;n[\"one\"] = 1;cout &lt;&lt; n[\"one\"] &lt;&lt; endl; 即赋值和索引功能。不能自动推断返回值类型，模板就没意义了。。。也许是我的数据结构没设计好？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_t#define ll long long#define index(c) (c - 'A')const int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;st weight(const char*s)&#123; st i = 0, x = 0; while (s[i]) x += index(s[i])*i, i += 1; return x + i;&#125;double str2float(const char *s, st p, st r)&#123; double num = 0, propoint = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num * sign;&#125;void bits(char s[], st &amp;i, ll x)&#123; if (!x) return; bits(s, i, x / 10); s[i++] = x % 10 + '0';&#125;void bits(std::string &amp;s, st &amp;i, ll x)&#123; if (!x) return; bits(s, i, x / 10); s[i++] = x % 10 + '0';&#125;std::string float2str(double num)&#123; ll x = (ll)num; st i = 0; double y = num - x; std::string s; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1) % 10 + '0'; &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;char* float2ch_arr(double num)&#123; ll x = (ll)num; st i = 0; double y = num - x; char* s = new char[N &gt;&gt; 1]; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1) % 10 + '0'; &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;ll con_char2int(const char *s)&#123; ll num = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s) num = num * 10 + (*s - '0'); return num * sign;&#125;ll str2int(std::string s)&#123; return con_char2int(s.c_str());&#125;std::string int2str(ll num)&#123; std::string s; st i = 0; if (num &lt; 0) s += \"-\", i++; bits(s, i, num); return s;&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;class BaseNode &#123;public: bool b_v; ll i_v; double d_v; std::string s_v; std::vector&lt;std::string&gt; arr_v; std::string key; st keys; bool isvalue; Type type; ll table[N]; BaseNode *children[N], *parent; BaseNode() &#123; keys = 0, isvalue = false, type = OBJECT, parent = nullptr; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; BaseNode(BaseNode*p, const char *k) &#123; std::string sk(k); key = sk, keys = 0, isvalue = false, parent = p; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void print(BaseNode*r, int format) &#123; if (r) &#123; std::cout &lt;&lt; '&#123;' &lt;&lt; std::endl; for (st i = 0; i &lt; r-&gt;keys; i++) &#123; BaseNode*node = r-&gt;children[i]; if (node) &#123; for (int j = 0; j &lt; format; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;key &lt;&lt; \"\\\" : \"; switch (node-&gt;type) &#123; case BOOL: std::cout &lt;&lt; (node-&gt;b_v ? \"true\" : \"false\"); break; case INTEGER: std::cout &lt;&lt; node-&gt;i_v; break; case FLOAT: std::cout &lt;&lt; node-&gt;d_v; break; case STRING: std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;s_v &lt;&lt; \"\\\"\"; break; case ARRAY: std::cout &lt;&lt; '['; for (st j = 0; j &lt; node-&gt;arr_v.size(); j++) &#123; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; \"\\\"\"; if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; \", \"; &#125; std::cout &lt;&lt; ']'; break; case OBJECT: print(r-&gt;children[i], format + 1); break; &#125; if (i != root-&gt;keys - 1) std::cout &lt;&lt; \",\"; std::cout &lt;&lt; std::endl; &#125; &#125; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; '&#125;' &lt;&lt; std::endl; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; &#125; &#125; BaseNode* findkey(BaseNode*r, const char*s) &#123; if (r) return r-&gt;children[r-&gt;table[weight(s)]]; return nullptr; &#125; void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(std::string s) &#123; parse(s.c_str()); &#125; void parse(const char *s) &#123; char str[N]; st i = 0; bool arr_sw = false, obj_sw = false, str_sw = false; root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (obj_sw) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; &#125; break; case '&#125;': nd = nd-&gt;parent; obj_sw = false; break; case '\"': if (str_sw) str_sw = false; else str_sw = true; if (i &gt; 0) &#123; bool b = false; double dounum = 0; ll intnum = 0; st f = 0, pos = 0; str[i] = '\\0'; if (!arr_sw) &#123; if (i &lt; 11) &#123; if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); else &#123; for (st j = 0; j &lt; i; j++) if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (st j = 0; j &lt; i; j++) if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; &#125; &#125; &#125; else f = 4; if (nd-&gt;isvalue) &#123; if (nd-&gt;children[nd-&gt;keys - 1]) &#123; std::string ps(str); switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; case 4: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY; nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps); break; &#125; &#125; &#125; else &#123; if (nd-&gt;table[weight(str)] == -1) &#123; BaseNode *n = new BaseNode(nd, str); nd-&gt;children[nd-&gt;keys] = n; &#125; &#125; i = 0, obj_sw = true; &#125; break; case ':': if (str_sw) str[i++] = *s; else &#123; if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; &#125; break; case ',': if (str_sw) str[i++] = *s; else &#123; if (!arr_sw) nd-&gt;isvalue = false; &#125; break; case ' ': if (str_sw) str[i++] = *s; break; case '[': arr_sw = true; break; case ']': arr_sw = false; break; case '/': if (str_sw) str[i++] = *s; break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; BaseNode*node = root-&gt;children[i]; std::string str = node-&gt;key; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; pstr += \"=\"; str.clear(); switch (node-&gt;type) &#123; case BOOL: if (node-&gt;b_v) str = \"true\"; else str = \"false\"; break; case INTEGER: str = int2str(node-&gt;i_v); break; case FLOAT: str = float2str(node-&gt;d_v); break; case STRING: str = node-&gt;s_v; break; default: std::cerr &lt;&lt; \"String parse error!\" &lt;&lt; std::endl; return \"\"; &#125; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125; auto getvalue(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123; /*switch(node-&gt;type) &#123; case BOOL: return node-&gt;b_v; case INTEGER: return node-&gt;i_v; case FLOAT: return node-&gt;d_v; case STRING: return node-&gt;s_v; case ARRAY: return node-&gt;arr_v; default: return node-&gt;children[node-&gt;table[weight(key)]]; &#125;*/ return node-&gt;s_v.c_str(); &#125; return \"\"; &#125; auto operator[](const char*key) &#123; return getvalue(key); &#125; template&lt;class T&gt; T&amp; operator=(T v) &#123; return v; &#125; template&lt;class T&gt; void setvalue(const char*key, T value) &#123; BaseNode*node = findkey(root, key); if (node) &#123; switch (node-&gt;type) &#123; case BOOL: node-&gt;b_v = value; break; case INTEGER: node-&gt;i_v = value; break; case FLOAT: node-&gt;d_v = value; break; case STRING: node-&gt;s_v = value; break; case ARRAY: node-&gt;arr_v = value; break; default: /* // 如果是直接在原本的value中进行添加，则不用清除，否则就清除所有子节点 for (st i = 0; i &lt; node-&gt;keys; i++) destory(node-&gt;children[i]); node-&gt;keys = 0;*/ for (st i = 0; i &lt; value.size(); i++) &#123; node-&gt;table[weight(value[i]-&gt;key)] = node-&gt;keys; value[i]-&gt;parent = node; node-&gt;children[node-&gt;keys++] = value[i]; &#125; break; &#125; &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; template&lt;class T&gt;void add(const char*key, T value) &#123; BaseNode*node = findkey(root, key); if (!node) &#123; BaseNode*n = new BaseNode(root, key); switch (n-&gt;type) &#123; case BOOL: n-&gt;b_v = value; break; case INTEGER: n-&gt;i_v = value; break; case FLOAT: n-&gt;d_v = value; break; case STRING: n-&gt;s_v = value; break; case ARRAY: n-&gt;arr_v = value; break; default: n-&gt;type = OBJECT; for (st i = 0; i &lt; value.size(); i++) &#123; n-&gt;table[weight(value[i]-&gt;key)] = n-&gt;keys; value[i]-&gt;parent = n; n-&gt;children[n-&gt;keys++] = value[i]; &#125; break; &#125; root-&gt;table[weight(key)] = root-&gt;keys++; root-&gt;children[root-&gt;keys - 1] = n; &#125; else &#123; std::cerr &lt;&lt; \"The key was existed!\" &lt;&lt; std::endl; return; &#125; &#125; void erase(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123; BaseNode*p = node-&gt;parent; p-&gt;keys--; p-&gt;table[weight(node-&gt;key.c_str())] = -1; destory(node); &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; void visual() &#123; print(root, 1); &#125;&#125;;int main()&#123; JsonTree r; std::fstream context(\"json.txt\", std::fstream::in | std::fstream::out | std::fstream::app); std::string line, str; while (std::getline(context, line)) str += line; context.close(); r.parse(str); r.visual(); // std::cout &lt;&lt; r.getvalue(\"time\") &lt;&lt; std::endl; std::cout &lt;&lt; r[\"Verdana\"] &lt;&lt; std::endl; // r.setvalue(\"time\", 154.2); std::cout &lt;&lt; r.getvalue(\"Latin_Modern\") &lt;&lt; std::endl; return 0;&#125; Update 2018-09-27am 05:03此次更新的主要内容 增加了通过key获取/设置对应的value的api:getvalue()、setvalue()； 增加了通过key删除key-value的api； 增加了函数weight()，它的作用是在json树内建一个weighth-table，使得能够通过传入关键字key，在 $ O(n) $（为关键字key字符串的长度）时间复杂度定位到key。详细防止映射冲突算法是通过将字符串每一位字符 c 减去 ascii 码 A的值乘以该字符所处的字符串中的位置，然后将每一位求和，最后再加上字符串长度。设字符串为 $ s $，长度为 $ l $，则用数学公式表示为： weight(s) = l + \\sum_{i = 0}^{l} (s[i] - 'A')*i 重载了[]符，使其能够通过字符串key来获取或设置value值。但并不完善。只能对一种类型的value进行操作； 增加了许多内置转换函数：bits()、float2str()、float2ch_arr()、int2str()、con_char2int； 修复了str2float()与str2int()为负数时的bug。 完善了之前一些没注意到地方的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_t#define ll long long#define index(c) (c - 'A')const int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;st weight(const char*s)&#123; st i = 0, x = 0; while (s[i]) x += index(s[i])*i, i += 1; return x + i;&#125;double str2float(const char *s, st p, st r)&#123; double num = 0, propoint = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num*sign;&#125;void bits(char s[], st &amp;i, ll x)&#123; if (!x) return ; bits(s, i, x/10); s[i++] = x%10 + '0';&#125;void bits(std::string &amp;s, st &amp;i, ll x)&#123; if (!x) return ; bits(s, i, x/10); s[i++] = x%10 + '0';&#125;std::string float2str(double num)&#123; ll x = (ll)num; st i = 0; double y = num - x; std::string s; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1)%10 + '0'; &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;char* float2ch_arr(double num)&#123; ll x = (ll)num; st i = 0; double y = num - x; char* s = new char[N &gt;&gt; 1]; bits(s, i, x); s[i++] = '.'; do &#123; y *= 10; s[i++] = int(y + 0.1)%10 + '0'; &#125; while (int(ceil(y)) != int(y + 0.1)); s[i] = 0; return s;&#125;ll con_char2int(const char *s)&#123; ll num = 0, sign = 1; if (*s == '-') s++, sign *= -1; while (*s) num = num * 10 + (*s - '0'); return num*sign;&#125;ll str2int(std::string s)&#123; return con_char2int(s.c_str());&#125;std::string int2str(ll num)&#123; std::string s; st i = 0; if (num &lt; 0) s += \"-\", i++; bits(s, i, num); return s;&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;class BaseNode &#123;public: bool b_v; ll i_v; double d_v; std::string s_v; std::vector&lt;std::string&gt; arr_v; std::string key; st keys; bool isvalue; Type type; ll table[N]; BaseNode *children[N], *parent; BaseNode() &#123; keys = 0, isvalue = false, type = OBJECT, parent = nullptr; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; BaseNode(BaseNode*p, const char *k) &#123; std::string sk(k); key = sk, keys = 0, isvalue = false, parent = p; for (int i = 0; i &lt; N; i++) table[i] = -1, children[i] = nullptr; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void print(BaseNode*r, int format) &#123; if (r) &#123; std::cout &lt;&lt; '&#123;' &lt;&lt; std::endl; for (st i = 0; i &lt; r-&gt;keys; i++) &#123; BaseNode*node = r-&gt;children[i]; if (node) &#123; for (int j = 0; j &lt; format; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;key &lt;&lt; \"\\\" : \"; switch (node-&gt;type) &#123; case BOOL: std::cout &lt;&lt; (node-&gt;b_v ? \"true\" : \"false\"); break; case INTEGER: std::cout &lt;&lt; node-&gt;i_v; break; case FLOAT: std::cout &lt;&lt; node-&gt;d_v; break; case STRING: std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;s_v &lt;&lt; \"\\\"\"; break; case ARRAY: std::cout &lt;&lt; '['; for (st j = 0; j &lt; node-&gt;arr_v.size(); j++) &#123; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; \"\\\"\"; if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; \", \"; &#125; std::cout &lt;&lt; ']'; break; case OBJECT: print(r-&gt;children[i], format + 1); break; &#125; if (i != root-&gt;keys - 1) std::cout &lt;&lt; \",\"; std::cout &lt;&lt; std::endl; &#125; &#125; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; '&#125;' &lt;&lt; std::endl; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; &#125; &#125; BaseNode* findkey(BaseNode*r, const char*s) &#123; if (r) return r-&gt;children[r-&gt;table[weight(s)]]; return nullptr; &#125; void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(std::string s) &#123; parse(s.c_str()); &#125; void parse(const char *s) &#123; char str[N]; st i = 0; bool arr_sw = false, obj_sw = false, str_sw = false; root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (obj_sw) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; &#125; break; case '&#125;': nd = nd-&gt;parent; obj_sw = false; break; case '\"': if (str_sw) str_sw = false; else str_sw = true; if (i &gt; 0) &#123; bool b = false; double dounum = 0; ll intnum = 0; st f = 0, pos = 0; str[i] = '\\0'; if (!arr_sw) &#123; if (i &lt; 11) &#123; if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); else &#123; for (st j = 0; j &lt; i; j++) if (str[j] == '.' || str[0] == '-' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (st j = 0; j &lt; i; j++) if (str[j] != '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; &#125; &#125; &#125; else f = 4; if (nd-&gt;isvalue) &#123; if (nd-&gt;children[nd-&gt;keys - 1]) &#123; std::string ps(str); switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; case 4: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY; nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps); break; &#125; &#125; &#125; else &#123; if (nd-&gt;table[weight(str)] == -1) &#123; BaseNode *n = new BaseNode(nd, str); nd-&gt;children[nd-&gt;keys] = n; &#125; &#125; i = 0, obj_sw = true; &#125; break; case ':': if (str_sw) str[i++] = *s; else &#123; if (nd-&gt;table[weight(str)] == -1) nd-&gt;table[weight(str)] = nd-&gt;keys++; nd-&gt;isvalue = true; &#125; break; case ',': if (str_sw) str[i++] = *s; else &#123; if (!arr_sw) nd-&gt;isvalue = false; &#125; break; case ' ': if (str_sw) str[i++] = *s; break; case '[': arr_sw = true; break; case ']': arr_sw = false; break; case '/': if (str_sw) str[i++] = *s; break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; BaseNode*node = root-&gt;children[i]; std::string str = node-&gt;key; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; pstr += \"=\"; str.clear(); switch(node-&gt;type) &#123; case BOOL: if (node-&gt;b_v) str = \"true\"; else str = \"false\"; break; case INTEGER: str = int2str(node-&gt;i_v); break; case FLOAT: str = float2str(node-&gt;d_v); break; case STRING: str = node-&gt;s_v; break; default: std::cerr &lt;&lt; \"String parse error!\" &lt;&lt; std::endl; return \"\"; &#125; for (st j = 0; j &lt; str.size(); j++) pstr += str[j]; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125; auto getvalue(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123;// switch(node-&gt;type)// &#123;// case BOOL: return node-&gt;b_v;// case INTEGER: return node-&gt;i_v;// case FLOAT: return node-&gt;d_v;// case STRING: return node-&gt;s_v;// case ARRAY: return node-&gt;arr_v;// default: return node-&gt;children[node-&gt;table[weight(key)]];// &#125; return node-&gt;d_v; &#125; return 0.0; &#125; auto operator[](const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123;// switch(node-&gt;type)// &#123;// case BOOL: return node-&gt;b_v;// case INTEGER: return node-&gt;i_v;// case FLOAT: return node-&gt;d_v;// case STRING: return node-&gt;s_v;// case ARRAY: return node-&gt;arr_v;// default: return node-&gt;children[node-&gt;table[weight(key)]];// &#125; return node-&gt;s_v.c_str(); &#125; return \"\"; &#125; template&lt;class T&gt; T&amp; operator=(T v) &#123; return v; &#125; template&lt;class T&gt; void setvalue(const char*key, T value) &#123; BaseNode*node = findkey(root, key); if (node) &#123; switch(node-&gt;type) &#123; case BOOL: node-&gt;b_v = value; break; case INTEGER: node-&gt;i_v = value; break; case FLOAT: node-&gt;d_v = value; break; case STRING: node-&gt;s_v = value; break; case ARRAY: node-&gt;arr_v = value; break; default: // 如果是直接在原本的value中进行添加，则不用清除，否则就清除所有子节点 // for (st i = 0; i &lt; node-&gt;keys; i++) // destory(node-&gt;children[i]); // node-&gt;keys = 0; for (st i = 0; i &lt; value.size(); i++) &#123; node-&gt;table[weight(value[i]-&gt;key)] = node-&gt;keys; value[i]-&gt;parent = node; node-&gt;children[node-&gt;keys++] = value[i]; &#125; break; &#125; &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; template&lt;class T&gt; void add(const char*key, T value) &#123; BaseNode*node = findkey(root, key); if (!node) &#123; BaseNode*n = new BaseNode(root, key); switch(n-&gt;type) &#123; case BOOL: n-&gt;b_v = value; break; case INTEGER: n-&gt;i_v = value; break; case FLOAT: n-&gt;d_v = value; break; case STRING: n-&gt;s_v = value; break; case ARRAY: n-&gt;arr_v = value; break; default: n-&gt;type = OBJECT; for (st i = 0; i &lt; value.size(); i++) &#123; n-&gt;table[weight(value[i]-&gt;key)] = n-&gt;keys; value[i]-&gt;parent = n; n-&gt;children[n-&gt;keys++] = value[i]; &#125; break; &#125; root-&gt;table[weight(key)] = root-&gt;keys++; root-&gt;children[root-&gt;keys - 1] = n; &#125; else &#123; std::cerr &lt;&lt; \"The key was existed!\" &lt;&lt; std::endl; return; &#125; &#125; void erase(const char*key) &#123; BaseNode*node = findkey(root, key); if (node) &#123; BaseNode*p = node-&gt;parent; p-&gt;keys--; p-&gt;table[weight(node-&gt;key.c_str())] = -1; destory(node); &#125; else &#123; std::cerr &lt;&lt; \"Not found the key!\" &lt;&lt; std::endl; return; &#125; &#125; void visual() &#123; print(root, 1); &#125;&#125;;int main()&#123; JsonTree r; std::fstream context(\"json.txt\", std::fstream::in | std::fstream::out | std::fstream::app); std::string line, str; while (std::getline(context, line)) str += line; context.close(); r.parse(str); r.visual(); // r.setvalue(\"time\", 156.35); std::cout &lt;&lt; r.getvalue(\"time\") &lt;&lt; std::endl; std::cout &lt;&lt; r[\"Verdana\"] &lt;&lt; std::endl; return 0;&#125; example123456789&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"] &#125;, \"time\" : \"-123.23\", \"flag\" : \"true\"&#125; output: 123456789101112&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"], &#125; , \"time\" : -123.23, \"flag\" : true&#125;-123.23 // r.getvalue(\"time\")fn_jvn // r[\"Verdana\"] Update 2018-09-26PS pm 15:21此次更新所作的主要工作： 将 obj_sw 完全设定为对象开关，如果遇到字符 { 便进入到更深的一层； 在数据结构中添加了 isvalue ，正如其名，用来判断正在解析的是否为 value； 完善了按 Json 格式化输出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_tconst int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;double str2float(const char *s, st p, st r)&#123; double num = 0, propoint = 0; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num;&#125;st str2int(const char *s)&#123; st num = 0; while (*s) num = num * 10 + (*s - '0'); return num;&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;class BaseNode &#123;public: bool b_v; st i_v; double d_v; std::string s_v; std::vector&lt;std::string&gt; arr_v; std::string key; st keys; bool isvalue; Type type; BaseNode *children[N], *parent; BaseNode() &#123; keys = 0, isvalue = false, type = OBJECT, parent = nullptr; for (int i = 0; i &lt; N; i++) children[i] = nullptr; &#125; BaseNode(BaseNode*p, const char *k) &#123; std::string sk(k); key = sk, keys = 0, isvalue = false, parent = p; for (int i = 0; i &lt; N; i++) children[i] = nullptr; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void print(BaseNode*r, int format) &#123; if (r) &#123; std::cout &lt;&lt; '&#123;' &lt;&lt; std::endl; for (st i = 0; i &lt; r-&gt;keys; i++) &#123; BaseNode*node = r-&gt;children[i]; if (node) &#123; for (int j = 0; j &lt; format; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;key &lt;&lt; \"\\\" : \"; switch (node-&gt;type) &#123; case BOOL: std::cout &lt;&lt; (node-&gt;b_v ? \"true\" : \"false\"); break; case INTEGER: std::cout &lt;&lt; node-&gt;i_v; break; case FLOAT: std::cout &lt;&lt; node-&gt;d_v; break; case STRING: std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;s_v &lt;&lt; \"\\\"\"; break; case ARRAY: std::cout &lt;&lt; '['; for (st j = 0; j &lt; node-&gt;arr_v.size(); j++) &#123; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; \"\\\"\"; if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; \", \"; &#125; std::cout &lt;&lt; ']'; break; case OBJECT: print(r-&gt;children[i], format + 1); break; &#125; if (i != root-&gt;keys - 1) std::cout &lt;&lt; \",\"; std::cout &lt;&lt; std::endl; &#125; &#125; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; std::cout &lt;&lt; '&#125;' &lt;&lt; std::endl; for (int j = 0; j &lt; format - 1; j++) std::cout &lt;&lt; '\\t'; &#125; &#125; void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(const char *s) &#123; char str[N]; int i = 0; bool arr_sw = false, obj_sw = false; root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (obj_sw) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; &#125; break; case '&#125;': nd = nd-&gt;parent; obj_sw = false; break; case '\"': if (i &gt; 0) &#123; bool b = false; double dounum = 0; st intnum = 0, f = 0, pos = 0; str[i] = '\\0'; if (!arr_sw) &#123; if (i &lt; 11) &#123; if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); else &#123; for (int j = 0; j &lt; i; j++) if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (int j = 0; j &lt; i; j++) if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; &#125; &#125; &#125; else f = 4; if (nd-&gt;isvalue) &#123; std::string ps(str); switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; case 4: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY; nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps); break; &#125; &#125; else &#123; BaseNode *n = new BaseNode(nd, str); nd-&gt;children[nd-&gt;keys] = n; &#125; i = 0, obj_sw = true; &#125; break; case ':': nd-&gt;keys += 1; nd-&gt;isvalue = true; break; case ',': if (!arr_sw) nd-&gt;isvalue = false; break; case ' ': break; case '[': arr_sw = true; break; case ']': arr_sw = false; break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; std::string str = root-&gt;children[i]-&gt;key; for (auto p : str) pstr += p; pstr += \"=\"; str = root-&gt;children[i]-&gt;s_v; for (auto p : str) pstr += p; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125; void visual() &#123; print(root, 1); &#125;&#125;;int main()&#123; char str[] = \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\", \\\"Verdana\\\":\\\"fn_jvn\\\", \\\"Object\\\": &#123;\\\"Color\\\": [\\\"red\\\", \\\"blue\\\", \\\"green\\\", \\\"white\\\"]&#125;, \\\"time\\\" : \\\"123.23\\\", \\\"flag\\\": \\\"true\\\"&#125;\"; JsonTree r; r.parse(str); r.visual(); return 0;&#125; output: 12345678910&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Object\" : &#123; \"Color\" : [\"red\", \"blue\", \"green\", \"white\"], &#125; , \"time\" : 123.23, \"flag\" : true&#125; PS am 3点左右此次更新所作的主要工作： 对数组类型做了解析判断； 重命名了变量 k 为 obj_sw，它的主要作用是判断当前数据 是 key 还是 value或者是 新的对象的入口。 添加了按 Json 格式输出的函数； 完善了一些之前的问题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_tconst int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;double str2float(const char *s, st p, st r)&#123; double num = 0, propoint = 0; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num;&#125;st str2int(const char *s)&#123; st num = 0; while (*s) num = num * 10 + (*s - '0'); return num;&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;class BaseNode &#123;public: bool b_v; st i_v; double d_v; std::string s_v; std::vector&lt;std::string&gt; arr_v; BaseNode *children[N]; std::string key; st keys; Type type; BaseNode() &#123; keys = 0, type = OBJECT; &#125; BaseNode(const char *k, st n) &#123; std::string sk(k); key = sk, keys = n; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void print(BaseNode*r) &#123; if (r) &#123; std::cout &lt;&lt; '&#123;' &lt;&lt; std::endl; for (st i = 0; i &lt; r-&gt;keys; i++) &#123; BaseNode*node = r-&gt;children[i]; if (node) &#123; std::cout &lt;&lt; '\\t' &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;key &lt;&lt; \"\\\" : \"; switch (node-&gt;type) &#123; case BOOL: std::cout &lt;&lt; (node-&gt;b_v ? \"true\" : \"false\"); break; case INTEGER: std::cout &lt;&lt; node-&gt;i_v; break; case FLOAT: std::cout &lt;&lt; node-&gt;d_v; break; case STRING: std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;s_v &lt;&lt; \"\\\"\"; break; case ARRAY: std::cout &lt;&lt; '['; for (st j = 0; j &lt; node-&gt;arr_v.size(); j++) &#123; std::cout &lt;&lt; \"\\\"\" &lt;&lt; node-&gt;arr_v[j] &lt;&lt; \"\\\"\"; if (j != node-&gt;arr_v.size() - 1) std::cout &lt;&lt; \", \"; &#125; std::cout &lt;&lt; ']'; break; case OBJECT: print(r-&gt;children[i]); break; &#125; if (i != root-&gt;keys - 1) std::cout &lt;&lt; \",\"; std::cout &lt;&lt; std::endl; &#125; &#125; std::cout &lt;&lt; '&#125;' &lt;&lt; std::endl; &#125; &#125; void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(const char *s) &#123; char str[N]; bool arr_sw = false; int i = 0, obj_sw = 0; root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (obj_sw &gt; 0) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; obj_sw = 0; &#125; break; case '&#125;': break; case '\"': if (i &gt; 0) &#123; bool b; double dounum = 0; st intnum = 0, f = 0, pos = 0; str[i] = '\\0'; if (!arr_sw) &#123; if (i &lt; 11) &#123; for (int j = 0; j &lt; i; j++) if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (int j = 0; j &lt; i; j++) if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; else if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); &#125; &#125; else f = 4; if (obj_sw &amp; 1) &#123; std::string ps(str); switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; case 4: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = ARRAY; nd-&gt;children[nd-&gt;keys - 1]-&gt;arr_v.push_back(ps); obj_sw -= 1; break; &#125; &#125; else &#123; BaseNode *n = new BaseNode(str, 0); nd-&gt;children[nd-&gt;keys] = n; &#125; i = 0, obj_sw += 1; &#125; break; case ':': nd-&gt;keys += 1; break; case ',': break; case ' ': break; case '[': arr_sw = true; break; case ']': arr_sw = false; break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; std::string str = root-&gt;children[i]-&gt;key; for (auto p : str) pstr += p; pstr += \"=\"; str = root-&gt;children[i]-&gt;s_v; for (auto p : str) pstr += p; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125; void visual() &#123; print(root); &#125;&#125;;int main()&#123; char str[] = \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\", \\\"Verdana\\\":\\\"fn_jvn\\\", \\\"Color\\\":[\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"white\\\"]&#125;\"; JsonTree r; r.parse(str); r.visual(); return 0;&#125; output: 12345&#123; \"Latin_Modern\" : \"fn_lm\", \"Verdana\" : \"fn_jvn\", \"Color\" : [\"red\", \"blue\", \"green\", \"white\"]&#125; Update 2018-9-25改用了部分C++的特点来编写该Json 解析器，目前只是一个十分简易的解析器，还有许多需要完善的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;string&gt;#define st size_tconst int N = 1000010;typedef enum &#123; BOOL, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;double str2float(const char *s, st p, st r)&#123; double num = 0, propoint = 0; while (*s != '.') num = num * 10 + (*s++ - '0'); s++; while (*s) propoint = propoint * 10 + (*s++ - '0'); num += propoint / std::pow(10, r - p); return num;&#125;int str2int(const char *s)&#123; int num = 0; while (*s) num = num * 10 + (*s - '0'); return num;&#125;bool str2bool(const char *s)&#123; bool var; if (s[0] == 't' &amp;&amp; s[1] == 'r' &amp;&amp; s[2] == 'u' &amp;&amp; s[3] == 'e' &amp;&amp; s[4] == '\\0') var = true; else var = false; return var;&#125;class BaseNode &#123;public: bool b_v; int i_v; double d_v; std::string s_v; BaseNode *children[N]; std::string key; st keys; Type type; BaseNode() &#123; keys = 0, type = OBJECT; &#125; BaseNode(const char *k, st n) &#123; std::string sk(k); key = sk, keys = n; &#125; ~BaseNode() &#123;&#125;&#125;;class JsonTree &#123;private: BaseNode *root; std::string pstr; /**/ void destory(BaseNode*&amp;r) &#123; if (r) &#123; for (st i = 0; i &lt; r-&gt;keys; i++) destory(r-&gt;children[i]); delete r; &#125; &#125;public: JsonTree() &#123; root = nullptr; &#125; JsonTree(const char* s) &#123; root = nullptr; parse(s); &#125; JsonTree(std::string s) &#123; root = nullptr; parse(s.c_str()); &#125; ~JsonTree() &#123; destory(root); &#125; void parse(const char *s) &#123; char str[N]; int i = 0, k = 0; root = new BaseNode(); BaseNode *nd = root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (k &gt; 0) &#123; nd = nd-&gt;children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; k = 0; &#125; break; case '&#125;': break; case '\"': if (i &gt; 0) &#123; bool b; double dounum = 0; int intnum = 0, f = 0, pos = 0; str[i] = '\\0'; for (int j = 0; j &lt; i; j++) if (str[j] == '.' || (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) f = 1; else &#123; f = 0; break; &#125; if (f) &#123; for (int j = 0; j &lt; i; j++) if (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9') f = 2; else &#123; f = 1, pos = j; break; &#125; if (f == 2) intnum = str2int(str); else dounum = str2float(str, pos, i - 1); &#125; else if ((str[0] == 't' &amp;&amp; str[1] == 'r' &amp;&amp; str[2] == 'u' &amp;&amp; str[3] == 'e' &amp;&amp; str[4] == '\\0') || (str[0] == 'f' &amp;&amp; str[1] == 'a' &amp;&amp; str[2] == 'l' &amp;&amp; str[3] == 's' &amp;&amp; str[4] == 'e' &amp;&amp; str[5] == '\\0')) f = 3, b = str2bool(str); if (k &amp; 1) &#123; std::string ps(str); nd-&gt;children[nd-&gt;keys - 1]-&gt;s_v = ps; switch (f) &#123; case 0: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = STRING; break; case 1: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = FLOAT; nd-&gt;children[nd-&gt;keys - 1]-&gt;d_v = dounum; break; case 2: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = INTEGER; nd-&gt;children[nd-&gt;keys - 1]-&gt;i_v = intnum; break; case 3: nd-&gt;children[nd-&gt;keys - 1]-&gt;type = BOOL; nd-&gt;children[nd-&gt;keys - 1]-&gt;b_v = b; break; &#125; &#125; else &#123; BaseNode *n = new BaseNode(str, 0); nd-&gt;children[nd-&gt;keys] = n; &#125; i = 0, k += 1; &#125; break; case ':': nd-&gt;keys += 1; break; case ',': break; case ' ': break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; &#125; std::string parse2url(const char*s) &#123; parse(s); for (st i = 0; i &lt; root-&gt;keys; i++) &#123; std::string str = root-&gt;children[i]-&gt;key; for (auto p : str) pstr += p; pstr += \"=\"; str = root-&gt;children[i]-&gt;s_v; for (auto p : str) pstr += p; if (i != root-&gt;keys - 1) pstr += \"&amp;\"; &#125; return pstr; &#125;&#125;;int main()&#123; char str[] = \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\", \\\"Verdana\\\":\\\"fn_jvn\\\", \\\"time\\\":\\\"723.34\\\"&#125;\"; // \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\",\\\"Verdana\\\":\\\"fn_jvn\\\", \\\"Color\\\":[\\\"red\\\",\\\"blue\\\",\\\"green\\\"]&#125;\" JsonTree r; std::string s = r.parse2url(str); std::cout &lt;&lt; \"https://darkchii.cn/s/\" &lt;&lt; s &lt;&lt; std::endl; return 0;&#125; output-vs2017 最新版本 123456https://darkchii.cn/s/Latin_Modern=fn_lm&amp;Verdana=fn_jvn&amp;time=723.34C:\\Users\\adimin\\source\\repos\\JsonParseMachine\\Debug\\JsonParseMachine.exe (process 18988) exited with code 0.To automatically close the console when debugging stops, enable Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.Press any key to close this window . . . output-g++ 6.3.0 1234https://darkchii.cn/s/Latin_Modern=fn_lm&amp;Verdana=fn_jvn&amp;time=723.34Process returned 0 (0x0) execution time : 0.243 sPress any key to continue. 未完成版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define SIZE 10010#define ll size_ttypedef enum &#123; BOOLEAN, INTEGER, FLOAT, STRING, ARRAY, OBJECT &#125; Type;typedef struct obj &#123; union &#123; bool b_v; int i_v; double d_v; const char *s_v; struct obj *children[SIZE]; &#125; value; const char *key; ll keys; Type type;&#125; JsonTrees;struct JsonObj &#123; JsonTrees *root;&#125;;void initialized(struct JsonObj **prt)&#123; *prt = (struct JsonObj *)malloc(sizeof(struct JsonObj)); (*prt)-&gt;root = (JsonTrees *)malloc(sizeof(JsonTrees)); memset((*prt)-&gt;root-&gt;value.children, 0, sizeof((*prt)-&gt;root-&gt;value.children)); (*prt)-&gt;root-&gt;type = OBJECT; (*prt)-&gt;root-&gt;key = NULL; (*prt)-&gt;root-&gt;keys = 0;&#125;JsonTrees *parse(const char *s)&#123; struct JsonObj *prt; JsonTrees *r, *nd; char str[SIZE]; int i = 0, k = 0; memset(str, 0, sizeof(str)); initialized(&amp;prt); nd = r = prt-&gt;root; while (*s) &#123; switch (*s) &#123; case '&#123;': if (k &gt; 0) &#123; nd = nd-&gt;value.children[nd-&gt;keys - 1]; nd-&gt;type = OBJECT; k = 0; &#125; break; case '&#125;': break; case '\"': if (i &gt; 0) &#123; str[i] = '\\0'; i = 0; if (k &amp; 1) &#123; nd-&gt;value.children[nd-&gt;keys - 1]-&gt;type = STRING; nd-&gt;value.children[nd-&gt;keys - 1]-&gt;value.s_v = str; &#125; else &#123; JsonTrees *n = (JsonTrees *)malloc(sizeof(JsonTrees)); memset(n-&gt;value.children, 0, sizeof(n-&gt;value.children)); n-&gt;keys = 0; n-&gt;key = str; nd-&gt;value.children[nd-&gt;keys] = n; &#125; k++; &#125; break; case ':': nd-&gt;keys++; break; case ',': break; case ' ': break; case '\\n': break; default: str[i++] = *s; break; &#125; s++; &#125; return r;&#125;void parse2url(JsonTrees *pt, char *url_endings)&#123; int j = 0; for (int i = 0; i &lt; pt-&gt;keys; i++) &#123; const char *ps = pt-&gt;value.children[i]-&gt;key; while (*ps) url_endings[j++] = *ps++; url_endings[j++] = '='; ps = pt-&gt;value.children[i]-&gt;value.s_v; while (*ps) url_endings[j++] = *ps++; url_endings[j++] = '&amp;'; &#125; url_endings[j - 1] = '\\0';&#125;void destory(struct JsonObj **prt, JsonTrees **pt)&#123; if (*pt) &#123; for (int i = 0; i &lt; (*pt)-&gt;keys; i++) destory(prt, &amp;(*pt)-&gt;value.children[i]); free(*pt); if (*prt) free(*prt); &#125;&#125;int main()&#123; char str[] = \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\",\\\"Verdana\\\":\\\"fn_jvn\\\"&#125;\"; // \"&#123;\\\"Latin_Modern\\\":\\\"fn_lm\\\",\\\"Verdana\\\":\\\"fn_jvn\\\", \\\"Color\\\":[red,blue,green]&#125;\" char url_eds[SIZE]; memset(url_eds, 0, sizeof(url_eds)); JsonTrees *r = parse(str); parse2url(r, url_eds); printf(\"https://darkchii.cn/s/\"); puts(url_eds); getchar(); return 0;&#125; 代码有个迷のbug，貌似每一个children的地址都被最后一个节点覆盖了，所以不管keyorvalue都是最后一个字符串fn_jvn，但我没找到原因。 这颗树类似这样的建立方式： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct T &#123; T *next[3]; int v;&#125;;struct P &#123; T* root;&#125;;T*init()&#123; P *pt = (P*)malloc(sizeof(P)); pt-&gt;root = (T*)malloc(sizeof(T)); T *next_n; next_n = pt-&gt;root; for (int i = 0; i &lt; 3; i++) &#123; T *n = (T*)malloc(sizeof(T)); memset(n-&gt;next, 0, sizeof(n-&gt;next)); n-&gt;v = i; next_n-&gt;next[i] = n; &#125; return pt-&gt;root;&#125;int main()&#123; T*head = init(); for (int i = 0; i &lt; 3; i++) &#123; printf(\"%d\\n\", head-&gt;next[i]-&gt;v); &#125; return 0;&#125; 这样写没有任何问题。","path":"2018/07/21/json-parser/","date":"07-21","excerpt":""},{"title":"日记/周记/月记/年记（不定时更新...）","text":"自带BGM 2018-07-30发现自己真的是一个很糟糕的人。。。 2018-08-01今天看了一部番叫《超能力女儿》，不说其他无意义的，我想每个看过的人都会有自己的想法。自己的那点一己之见还不如拿来刷题233，但还是要点赞的是，真的挺好看的~ 还有前几天看的《混沌武士》也不错，是因为打斗动作很流畅补的，看完发现这部番除了打斗外也不错！ 2018-08-11学习日语 以前学过一点五十音，但没多久中断了，这次打算从零开始持续学习~首先是把电脑系统加上了日本输入法，然后再把五十音、浊音/半浊音、拨音、促音、拗音、长音记熟。 2018-08-17下面是在网上找到的一段日语，我试着独立标注一下罗马音（google 翻译，但对一些实在不通顺的地方做了修改）。 问题：水はなんで腐るの？问题描述：水ってH2Oですよね。つまり無機物。だからどう考えても腐りようがないと思うんです。何で腐るんですか？ 罗马音：mizuwa nande kusa runo?原句子： 水は なんで 腐 るの？翻译：水为什么会腐烂呢？ 罗马音：mizutsute H2Odesu yone。tsu mari mukibutsu。原句子： 水って H2Oです よね。 つ まり 無機物。翻译：水是H2O吧。也就是无机物。 罗马音：dakara dou kangaete mo kusariyou ga nai to omoun desu。原句子：だから どう 考えて も 腐りよう が ない と 思うん です。翻译：所以不管怎么去考虑，它也不会腐烂。 罗马音：nan de kusarun desu ka?原句子： 何 で 腐るん です か？翻译：那为什么会腐烂呢得斯嘎? （p.s.学习一个星期了，加油~~ 2018-08-19今天早上睁眼看手机时看了一道算法题，然后脑洞了一个算法，类似hash表(我认为它是一个链式hash表)，通过数组下标映射到下标上的值，再通过該值作为下标来继续映射找到数组中重复的数据。但使用有几个前提： 1.数组中所有数据不能大于数组长度2.重复的数据必须排列在数组最左端3.必须要有与重复数据长度相等数据4.以重复数据为下标的位置上的数不能是重复数据位置的下标大小(下标从0开始算)5.所有数据重复出现次数不能大于2。 释义:比如 5,3,5,4,2,3,6,7该数组中3,5是重复数据，长度为2，所有数据的大小都小于8，2出现在数组中，5,3排在数组最前面，数组中第5个位置上的数不为0，第3个位置上的数不为1，所有数据重复次数不大于2。条件满足。所以一定能找到5,3的重复数据。最后一个条件的原因是假如相同，就会导致死循环(比如:35456173,这里重复的是3,5 但第5个位置上是1，1正好是5的下标，所以会死循环)。再比如，5,4,6,5,3,4,6,7重复的有 5,4,6，这3个数只要满足前面5个条件，就一定能找到对应的另一重复数。 更多例子: 54534267、54524367、54523467、23543267、63546327 :) 不过使用条件非常刻苛刻wwww，所以没什么用。。或许可以用在海量数据满足上述5个条件中，查找到所有重复数据的下标位置。。然而时间复杂度可能为 $ O(nlgn) $ 。。。 算法实现12345678910111213#include &lt;iostream&gt;int arr[] = &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;;int mapping(int i, int n)&#123; if (arr[i] == arr[n] &amp;&amp; i != n) return n; // 下标 return mapping(i, arr[arr[n]])&#125;int main()&#123; std::cout &lt;&lt; mapping(0, 0) &lt;&lt; std::endl; return 0;&#125; 还有一个七夕恶搞数列题，用手没推出通项公式(应该没有通项公式)，答案就是下一年单身的时长为365天😂… 原题：数列 $ {a_n} $ 满足: $ a_1 = \\frac{1}{2} $， $ a_{n + 1} = a_n + \\frac{a_n^2}{n} $，求 $ 100a_7 $。 123456789101112#include &lt;stdio&gt;double a(int n)&#123; if (n == 1) return 0.5; return a(n - 1) + a(n - 1)*a(n - 1)/(n - 1);&#125;int main()&#123; std::cout &lt;&lt; 100*a(7) &lt;&lt; std::endl; return 0;&#125; 2018-08-30今日わね たくさん 日本語 勉強しました。でも あまり熟練でわありません です。えと…さっき 単語を 一つ と 文を 一つも 習いました。えと…その文わこの様なものです：“この薬は 日に 3回 飲んでください。”えと…まずそれをやりましょう。頑張ります!! 2018-09-28命运石之门0完结了。。。好难过。 2018-10-09最近发现国学的重要性了，因为发现自己想要对美好的事物表示赞叹时，却何其的词穷（比如上面这段日记）。。。该看点文学作品了。 2018-10-18哦？今年的夏天，好像连夏日最后的一丝温暖都还未触摸到就被凉意惊醒了。记不清季节的我看了一下日历，才发现昨天是重阳节。 我到底在做什么？我自己也不知道，就这么随意任性的在家里宅了快3个月。时间就这么无情的流逝，无声的流逝让我感到可怕。啊，真希望时间能在我消沉、抑郁的时候停止，但这样或许我的时间将永远不在前进。 （p.s.最近也没怎么学日语。。。 2018-10-22回想起来，还在上高中时，虽然只是中二时期，但也还是立下好多美好的愿望呢，比如，看完国学作品、看完夏目漱石的《吾辈わ猫である》、名人传记等等（敢想象我当时还是一个理科生吗，嘛，其实我一直没觉得自己是一个理科生，不过，也没觉得自己是文科生，而是对这个毫无概念），然而至今一个也没有完成。 今天去书店了，偶然看到了《我是猫》，回忆起那时在学校书本上看到的一段该作品的节选，当时就被文章名以及作者的叙事手法吸引住了，看完后虽然说不出太多感想，但觉得很喜欢，但又因为只是节选，然后决定以后有钱一定买书看完整的，说起来，当时的自己连上网也不太会，也没啥上网的环境，更不太懂找资源，emm，嘛，苦逼学生一个。不过，后来有一次去书店买书，结果也给忘记了。哎。emm，今天在书店里又拿起看了一会儿，嗯，果然不错，现在更作为一个养猫的人，我感觉能更有代入感了，说实话，我对我家猫也是又爱又恨。 时常在想什么时候自己也能写出如此吸引人的故事呢？ 自己也想过当一个写手，虽然文笔很差，但总是没有自信去开始。 最早有这个想法的时候还是大一那会儿，听了一首特别具有神话气息的歌曲，看到评论区大家一起编写的有趣的故事，联想到不知是自己在何时听闻来的故事。只有淡淡的印象，那是一个凄美的神话爱情故事。相信大家在小时候也或多或少在一些地方了解到这样一些凄美的神话故事，虽然可能很短，虽然可能并不太理解，但却留下了淡淡的印象。长大后，才明白其中的美。现在每当听到这样的歌曲和看到这样凄美的神话故事时，不知为何内心都会有一种淡淡的疼痛。 我发现别人都很认真也很勤劳。他们每当看完一部作品后，都会很认真的为作品写一篇感想文，内容质量也都很不错，这一点让我觉得很惭愧。 于是决定改天把《我是猫》看完以后，动手写一篇感想。 多看书，多积累一些常识和知识作为素材。 这些素材其实都是作为写手的资本，嗯，如果想成为一个写手，我想，经验和丰富的知识是最重要的基础条件。 对经验也很重要，体会过，理解过，在那个时间、那个场所留下过自己强烈的存在，我个人认为这样才能称为经验。 嘛，经验这种东西也是可遇不可求的。 比如恋爱经验我可能这辈子也无缘了。 2018-10-23早上6点多起床吃了早餐（虽然只是简单到没有其他佐料的面条）。 决定整理一下博客，准备了一些图片，打算筛选一下为主页中每篇文章的设置一张不一样的图。 弄了一小会儿，转头发现床上有一只萤火虫，虽然一开始被吓了一跳，以为是什么虫子呢。但仔细看发现是萤火虫，嗯，意外的感觉好开心，因为已经很久没见到萤火虫了。 嗯，感觉心情不错。 希望今天一天的心情能保持下去~","path":"2018/07/15/write-something/","date":"07-15","excerpt":""},{"title":"Hello World","text":"个人小站建立时间2018-07-06","path":"2018/07/10/hello-world/","date":"07-10","excerpt":""}]}